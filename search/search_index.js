var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Argos CTRE Swerve Test Repository","text":"<p>Documentation of all the little things we found while developing this repository</p>"},{"location":"index.html#how-to-get-a-raw-button-from-a-joystick","title":"How to get a raw button from a joystick","text":"<p>In lots of cases, you will need to fetch if a button is on or off, and make the robot do some task based off of that button. There exists two ways of doing this:</p> <ul> <li>Passing a command to a trigger to run with one of the <code>OnTrue</code>, <code>OnFalse</code>, <code>WhileTrue</code>, <code>WhileFalse</code>, etc functions</li> <li>Getting the button state itself from inside a default command.</li> </ul> <p>The following example shows the second way, from inside of a default command. This example uses a bit of code from the repository linked in the top-right.</p> <pre><code>// You will have some joystick object before here, like: `joystick`\n//   For this example, we assume it has type: `frc2::CommandXboxController`\n// Also, assuming you generated this project then you should have the drivetrain\n//   subsystem as well. \n// If you are new to this code, and it was given to you, you probably already\n//   have all this\n\nvoid RobotContainer::ConfigureBindings()\n{\n    // Assume MaxSpeed and MaxAngularRate was written somewhere else...\n\n    // Stuff ...\n\n    drivetrain.SetDefaultCommand(\n        // Drivetrain will execute this command periodically\n        drivetrain.ApplyRequest([this]() -&gt; auto&amp;&amp; {\n            // HERE is where we will start putting our code to make \n            //   decisions based off of the buttons. \n\n            // This is your drive speed multiplier\n            double driveSpeed = 0.15;\n\n            // Inside of the default command, we can get the raw true/false (on/off)\n            //   value of the joystick wihtout having to mess with commands\n            if (joystick.RightBumper().Get())\n            {\n                // If the right bumper is pressed, set drive speed to 0.5\n                //   if not, this will not run and drive speed will remain 0.15\n                driveSpeed = 0.5;\n            }\n\n            // Now, the drivetrain will use the `driveSpeed` variable\n            return drive.WithVelocityX(-joystick.GetLeftY() * MaxSpeed * driveSpeed) // Drive forward with negative Y (forward)\n                .WithVelocityY(-joystick.GetLeftX() * MaxSpeed * driveSpeed) // Drive left with negative X (left)\n                .WithRotationalRate(-joystick.GetRightX() * MaxAngularRate); // Drive counterclockwise with negative X (left)\n        })\n    );\n\n    // More stuff ...\n}\n</code></pre>"},{"location":"index.html#odometry-is-off-solutions","title":"Odometry is off solutions","text":"<ul> <li>Check wheel diameter &amp; that it is accurate</li> </ul>"},{"location":"tutorials/arcade-drive.html","title":"Arcade Drive (Intro Programming)","text":"<p>Welcome to learning Arcade Drive!. This tutorial is meant to prepare you for both programming and learning how to design systems for command-based robots in FRC. This tutorial assumes you have little to no experience in C++, and will walk you through every step from project creation to driving a robot.If a section seems to boring/trivial, skip to the next. In order to accomadate all skill levels, we'll start from almost zero.</p>"},{"location":"tutorials/arcade-drive.html#if-its-your-first-time-here","title":"If it's your First Time Here...","text":"<p>If this is your first introduction to programming in the FRC ecosystem: welcome!!.</p> <p>In FRC, robots are programmed using the C++ language alongside the WPILib control system, which is essentially just a big tool box that we use to create software for the robots. We won't dig into the guts here, but if you want to read more: follow the link above.</p>"},{"location":"tutorials/arcade-drive.html#so-programming","title":"So - Programming? \ud83d\udcbb","text":"<p>We typically think of computers as black boxes: we click on pictures on a screen, and somehow this magical box of silicon tricks spits out websites, games, videos, and all manners of sorcery.</p> <p>Turns out, it's not magic at all: just code! The robot you are about to write for is no different, except it's missing everything we use to interract with a computer: mouse, keyboard, screen, sound, etc.</p> <p>This is an example of a so-called embedded system. From Wikipedia:</p> <p>\"An embedded system is a specialized computer system\u2014a combination of a computer processor, computer memory, and input/output peripheral devices\u2014that has a dedicated function within a larger mechanical or electronic system.\"</p> <p>Long story short: it is a computer that has no way for you, the user, to give it input  (at least in traditional ways). The computer is designed to do one thing over and over again, without much complaining.</p> <p>In FRC, the rules designate that we must use a RoboRio 2 by National Instruments that looks like this:</p> <p></p> <p>This is the comptuer you are writing code for! In ARGOS 1756, we use the C++ language, but it is also possible to write code using Python, Java, and LabView.</p> <p>If you don't know what a programming language is, it is just like any other language (Spanish, French, German) but instead of talking beteween people, you are talking to comptuers.</p>"},{"location":"tutorials/arcade-drive.html#meet-your-robot","title":"Meet Your Robot. \ud83e\udd16","text":"<p>The NI RoboRio is pretty expensive, and requires a lot more hardware to get a  minimal robot working, so we've decided to help you learn using Sparkfun's XRP Platform:</p> <p></p> <p>The beautiful thing about this robot is you can program it using WPILib! This makes it perfect for low-risk, low-cost training. This will be the robot you get driving around with this tutorial.</p>"},{"location":"tutorials/arcade-drive.html#from-zero-to-hello-world","title":"From Zero to \"Hello World!\" \u270b","text":"<p>Go ahead and open another browser tab away from this one and go to  onlinegdb.com/online_c++_compiler  so you can write some code in your browser without downloading any of the complicated tooling. (which you will need later to program the robot).</p> <p>Commonly, programmers start a new language by writing a very simple program that tells the user <code>Hello World!</code> it will print this message to the terminal. While normal people don't typically interract with terminals, it offers a very simple  way to get output from your code, to the user. </p> <p>Why no pretty windows?</p> <p>Why would we use this \"terminal\" if we always have pretty buttons and text to click on? Well, put short: it's a lot more code to make things pretty. The terminal uses a  built-in feature to most operating systems called stdout (standard-out). This a much easier way to talk to a user.</p> <p>For this exercise, just copy-paste the code below into the text editor on the website:</p> <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    std::cout &lt;&lt; \"Hello, World!\\n\";\n\n    return 0;\n}\n</code></pre> <p>Click \"Run\" on the top, and see what happens! You should see the following output in the terminal at the bottom:</p> <pre><code>Hello, World!\n</code></pre> <p>Congradulations!!</p> <p>You just wrote your first C++ program. Take a minute to take in what each of these lines sort of mean:</p> <pre><code>#include &lt;iostream&gt; // Includes code that lives \"elsewhere\" \n                    //   (don't worry about what that means for now).\n                    // This \"iostream\" gives me the ability to use the code\n                    //   I've written below to print to the terminal.\nint main()\n{ // Everything between this open bracket and the following closing bracket is part of \"main\"\n\n    // This is where your code will start running. We call \"main\" the \"entry-point\"\n    //   because it is where your code will start running. main is special because\n    //   the computer \"looks for\" this function to execute first.\n\n    // The line below is what actually prints to the terminal\n    std::cout &lt;&lt; \"Hello, World!\\n\";\n\n    // returning the number zero means \"the program worked OK!\"\n    return 0;\n\n} // The end of \"main\"\n</code></pre> <p>Comments</p> <p>Comments are those bits of text I wrote starting with <code>//</code>. Everything after <code>//</code> in a line the computer will ignore. These are called \"comments\" and programmers use them to communicate the intenet of code to other programmers.</p> <p>Now you've written your first bit of magi- I mean code. While simple, this highlights a few important concepts that you will need throughout the entirety of your hopefully long and  prosperous software journey:</p> <p>Code executes from \"top to bottom\"</p> <p>First, we included, then we wrote the console, then we \"returned\" zero.</p> <p>Returning Values</p> <p>When you run a \"function\" (what \"main\" is) you can give values back to other parts of code: which is what we are doing with the \"0\". We give it back to whatever called (ran) our \"main\" function.</p> <p>Including Libraries</p> <p>We call collections of other people's (or our own) code \"libraries\", we can include these by... well, the <code>#include</code> of course! For this case, in order to write the line <code>std::cout &lt;&lt; \"Hello, World!\\n\";</code>, we need to include <code>iostream</code> which we do by writing:  <code>#include &lt;iostream&gt;</code>. <code>iostream</code> contains some code that comes with C++ that helps us write to the terminal.</p>"},{"location":"tutorials/arcade-drive.html#quicksave-here-for-later","title":"Quicksave Here for Later \ud83d\udcbe","text":"<p>The last section was pretty much the most bare-bones basic example you can do with any programming language. You can imagine that there is some complexities that lie between printing \"Hello World!\" to a user and programming a robot with tons of  motors, sensors, and moving parts. </p> <p>This is true, but don't let it overwhelm you. The most important thing to remember is that every system can be broken up into little pieces. </p> <p>This tutorial is skipping a lot about C++ and programming in general to focus specifically on writing code for robots. If you want, finish this tutorial then come back here and follow a couple of these links to learn more general programming and C++:</p> <ul> <li>Codecademy Free C++ Course</li> <li>FreeCodeCamp Youtube Video</li> </ul> <p>For reference (looking up standard functions &amp; libraries) I personally prefer:</p> <ul> <li>Cpp Reference - Fair warning: it's very wordy and technical</li> </ul> <p>CPP Reference Example</p> <p>For example, if you wanted to know what all is inside <code>iostream</code> you can go here and then from there read about cout</p>"},{"location":"tutorials/arcade-drive.html#your-robotic-task","title":"Your Robotic Task \ud83d\udcce","text":"<p>Your task for the rest of this tutorial is to get a robot to move.  Specifically, it needs to move in a way that we call Arcade Drive. </p> <p>Arcade Drive is just a way we use to describe what we expect the robot to do when you move the two sticks on a classic x-box controller. The idea here is that the left stick moves the robot forward/back and the right stick turns. For those of you that play video games: yea it's that.</p> <p>Assumptions About Software</p> <p>This tutorial is making the assumption you are working on a machine that  has all the tools you need installed for you by your resident tech guru. If you're missing these tools, go summon your guru to bestow upon you the  tools needed to write code for robots.</p> <p>First off, let's get a quick picture of what we want the robot to do:</p> <p></p> <p>Like we described before, the left stick controls the \"power\" either forward or back from the robot, and the right stick controls the left and right \"power\".</p>"},{"location":"tutorials/arcade-drive.html#the-pre-code-workout","title":"The Pre-Code Workout \ud83d\udcca","text":"<p>Before we write any code, it's important to make a flow chart of what we need to do, in human readable tasks. When you are solving any problem in software, it's important to do a step like this either in your head, or on paper.</p> <p>Let's start with listing out the tasks we need to perform:</p> <ul> <li>Turn robot left and right</li> <li>Drive forward and back</li> <li>Read left stick from controller</li> <li>Read right stick from controller</li> </ul> <p>Now that we have that, let's make a chart of what our code needs to do. Programmers use flow charts a lot to visualize a plan for implementing code:</p> <pre><code>flowchart TD\n    a[Read right stick from controller]\n    b[Read left stick from controller]\n    c[Set forward speed]\n    d[Set turn speed]\n\n    s(start) --&gt; a\n    a --&gt; b\n    b --&gt; c\n    c --&gt; d</code></pre> <p>While simple, it's important to keep the tasks at hand striat. I will walk you  through how to do each of these things in code in the next section.</p>"},{"location":"tutorials/arcade-drive.html#project-creation-setup","title":"Project Creation &amp; Setup \ud83c\udfd7\ufe0f","text":"<p>XRP Only</p> <p>These instructions are designed for the XRP robot ONLY. Similar concepts apply for full-scale robots, but this is by no means an arcade tutorial for swerve drive. This code assumes that some things are present from  specifically the XRP example generated by WPILib</p> <p>To start things off, you'll need to open 2025 VsCode from the start menu /  desktop. Wherever it is located.</p> <p>From here, I will defer to WPILib for how to create the XRP project. Follow the instructions on this  page (including running the program) and then come back here when you are done.</p> <p>Success</p> <p>Congrats!!! If you went to WPILib, followed the docs, and came back here: you just followed your first technical documentation tutorial!</p>"},{"location":"tutorials/arcade-drive.html#but-where-is-main-i-thought-thats-where-code-went","title":"But... Where is <code>main</code>? I thought that's where code went?","text":"<p>Ok yes, you caught me. This is one of those \"complexities\" I mentioned earlier. The <code>main</code> function here is burried deep, deeper than we will ever go into the toolbox that is WPILib. We won't ever interract with it at all. </p> <p>You'll notice there are lots of files in this project, so it can be hard to  tell where we start. For now: just accept that we will be primarily working in the file <code>RobotContainer.cpp</code>. This file \"contains\" different commands that will be run on the robot. (Imagine that, robot container containing the robot?)</p> <p>VSCode Shortcut</p> <p>Use the shortcut <code>ctrl+p</code> to get a search bar where you can type in any file name, and VSCode will take you there. You can also use <code>ctrl+shift+p</code> to get the command pallate, where you can type pretty much any command you can click.</p> <p>Go ahead and open that <code>RobotContainer.cpp</code> file. It should be under: <code>/src/main/cpp</code> inside of your project. Navigate to it using the shortcut from the tip above, or with the explorer on the left.</p> <p>This is where we will do most of our writing.</p>"},{"location":"tutorials/arcade-drive.html#finally-lets-write-some-code","title":"Finally - Let's Write Some Code \u270d\ufe0f","text":"<p>Your file (<code>RobotContainer.cpp</code>) should look like this to start:</p> <pre><code>// Copyright (c) FIRST and other WPILib contributors.\n// Open Source Software; you can modify and/or share it under the terms of\n// the WPILib BSD license file in the root directory of this project.\n\n#include \"RobotContainer.h\"\n\n#include &lt;frc/smartdashboard/SmartDashboard.h&gt;\n#include &lt;frc2/command/Commands.h&gt;\n#include &lt;frc2/command/button/JoystickButton.h&gt;\n\n#include \"commands/TeleopArcadeDrive.h\"\n\nRobotContainer::RobotContainer() {\n  // Configure the button bindings\n  ConfigureButtonBindings();\n}\n\nvoid RobotContainer::ConfigureButtonBindings() {\n  // Also set default commands here\n  m_drive.SetDefaultCommand(TeleopArcadeDrive(\n      &amp;m_drive, [this] { return -m_controller.GetRawAxis(1); },\n      [this] { return -m_controller.GetRawAxis(2); }));\n\n  // Example of how to use the onboard IO\n  m_userButton.OnTrue(frc2::cmd::Print(\"USER Button Pressed\"))\n      .OnFalse(frc2::cmd::Print(\"USER Button Released\"));\n\n  frc2::JoystickButton(&amp;m_controller, 1)\n      .OnTrue(frc2::cmd::RunOnce([this] { m_arm.SetAngle(45_deg); }, {}))\n      .OnFalse(frc2::cmd::RunOnce([this] { m_arm.SetAngle(0_deg); }, {}));\n\n  frc2::JoystickButton(&amp;m_controller, 2)\n      .OnTrue(frc2::cmd::RunOnce([this] { m_arm.SetAngle(90_deg); }, {}))\n      .OnFalse(frc2::cmd::RunOnce([this] { m_arm.SetAngle(0_deg); }, {}));\n\n  // Setup SmartDashboard options.\n  m_chooser.SetDefaultOption(\"Auto Routine Distance\", &amp;m_autoDistance);\n  m_chooser.AddOption(\"Auto Routine Time\", &amp;m_autoTime);\n  frc::SmartDashboard::PutData(\"Auto Selector\", &amp;m_chooser);\n}\n\nfrc2::Command* RobotContainer::GetAutonomousCommand() {\n  return m_chooser.GetSelected();\n}\n</code></pre>"},{"location":"tutorials/arcade-drive.html#header-files","title":"Header Files","text":"<p>The very first thing I want to draw your attention to is the <code>#include</code> towards the top:</p> <pre><code>#include \"RobotContainer.h\"\n</code></pre> <p>You'll notice that this is including (or rather, taking the code of and using it here)  a file called <code>RobotContainer.h</code>. This is actually a file located within our project at: <code>src/main/include/RobotContainer.h</code>.</p> <p>This is called a \"Header\" file. Most \"parts\" of software in any C++ projects come in pairs of files. A \"source\" file (<code>RobotContainer.cpp</code>) and a \"header\"  file: (<code>RobotContainer.h</code>). Each one has it's own job:</p> <ul> <li>The source file contains the \"actual\" code that is used on the robot.</li> <li>The header file tells other source files what to expect from your code.</li> </ul> <p>I know that was probably a little confusing, but let's look at a concrete example:</p> <p>Looking at the <code>RobotContainer.cpp</code> file, you'll see a couple functions with funny synatx:</p> <pre><code>RobotContainer::RobotContainer() {\n  // Stuff in here ...\n}\n\nvoid RobotContainer::ConfigureButtonBindings() {\n  // Stuff in here ...\n}\n\nfrc2::Command* RobotContainer::GetAutonomousCommand() {\n  // Stuff in here ...\n}\n</code></pre> <p>Now, use the explorer or <code>ctrl+p</code> shourtcut to look at the file <code>RobotContainer.h</code>:</p> <pre><code>// Copyright (c) FIRST and other WPILib contributors.\n// Open Source Software; you can modify and/or share it under the terms of\n// the WPILib BSD license file in the root directory of this project.\n\n#pragma once\n\n#include &lt;frc/Joystick.h&gt;\n#include &lt;frc/smartdashboard/SendableChooser.h&gt;\n#include &lt;frc/xrp/XRPOnBoardIO.h&gt;\n#include &lt;frc2/command/Command.h&gt;\n#include &lt;frc2/command/CommandPtr.h&gt;\n#include &lt;frc2/command/button/Trigger.h&gt;\n\n#include \"Constants.h\"\n#include \"commands/AutonomousDistance.h\"\n#include \"commands/AutonomousTime.h\"\n#include \"subsystems/Arm.h\"\n#include \"subsystems/Drivetrain.h\"\n\n/**\n * This class is where the bulk of the robot should be declared.  Since\n * Command-based is a \"declarative\" paradigm, very little robot logic should\n * actually be handled in the {@link Robot} periodic methods (other than the\n * scheduler calls).  Instead, the structure of the robot (including subsystems,\n * commands, and button mappings) should be declared here.\n */\nclass RobotContainer {\n  // NOTE: The I/O pin functionality of the 5 exposed I/O pins depends on the\n  // hardware \"overlay\"\n  // that is specified when launching the wpilib-ws server on the Romi raspberry\n  // pi. By default, the following are available (listed in order from inside of\n  // the board to outside):\n  // - DIO 8 (mapped to Arduino pin 11, closest to the inside of the board)\n  // - Analog In 0 (mapped to Analog Channel 6 / Arduino Pin 4)\n  // - Analog In 1 (mapped to Analog Channel 2 / Arduino Pin 20)\n  // - PWM 2 (mapped to Arduino Pin 21)\n  // - PWM 3 (mapped to Arduino Pin 22)\n  //\n  // Your subsystem configuration should take the overlays into account\n public:\n  RobotContainer();\n  frc2::Command* GetAutonomousCommand();\n\n private:\n  // Assumes a gamepad plugged into channel 0\n  frc::Joystick m_controller{0};\n  frc::SendableChooser&lt;frc2::Command*&gt; m_chooser;\n\n  // The robot's subsystems\n  Drivetrain m_drive;\n  Arm m_arm;\n  frc::XRPOnBoardIO m_onboardIO;\n\n  // Example button\n  frc2::Trigger m_userButton{\n      [this] { return m_onboardIO.GetUserButtonPressed(); }};\n\n  // Autonomous commands.\n  AutonomousDistance m_autoDistance{&amp;m_drive};\n  AutonomousTime m_autoTime{&amp;m_drive};\n\n  void ConfigureButtonBindings();\n};\n</code></pre> <p>There's a lot to unpack here, but if you read carefully... you'll find each of those functions we have in <code>RobotContainer.cpp</code>:</p> <ul> <li><code>GetAutonomousCommand</code></li> <li><code>RobotContainer</code></li> <li><code>ConfigureButtonBindings</code></li> </ul> <p>All of these are inside a \"class\" which is another programming concept. Classes are a little out of scope for this tutorial, but essentially: they are ways to  organize code into objects. \"Objects\" in programming are models of real world things. For instance, we could have a class that represents a toaster.  Toasters have functions: <code>toastBread()</code>, <code>turnOff()</code> and \"properties\" (something like color, or it's manufactured date).</p> <p>I know that was a BIG tangent, but this is one of the few concepts that is very easy to miss, but also very important to being able to read code. If you are only reading the <code>.cpp</code> file, you're only getting half the story.</p> <p>Header Shortcut</p> <p>If you have already built your project, you can usually use <code>alt+o</code> (the lowercase letter 'o') to navigate between a cpp/h file. Try it on <code>RobotContainer.cpp</code>!</p>"},{"location":"tutorials/arcade-drive.html#trimming-the-fat","title":"Trimming the Fat","text":"<p>Okay so technically this project already implements arcade drive for you  out of the box, but we want to do it ourselves. Go ahead and delete all of the content in <code>ConfigureButtonBindings</code> in the <code>RobotContainer.cpp</code> file.  Your file should now look like this:</p> <pre><code>// Copyright (c) FIRST and other WPILib contributors.\n// Open Source Software; you can modify and/or share it under the terms of\n// the WPILib BSD license file in the root directory of this project.\n\n#include \"RobotContainer.h\"\n\n#include &lt;frc/smartdashboard/SmartDashboard.h&gt;\n#include &lt;frc2/command/Commands.h&gt;\n#include &lt;frc2/command/button/JoystickButton.h&gt;\n\n#include \"commands/TeleopArcadeDrive.h\"\n\nRobotContainer::RobotContainer() {\n  // Configure the button bindings\n  ConfigureButtonBindings();\n}\n\nvoid RobotContainer::ConfigureButtonBindings() {\n}\n\nfrc2::Command* RobotContainer::GetAutonomousCommand() {\n  return m_chooser.GetSelected();\n}\n</code></pre> <p>Don't worry about the <code>RobotContainer</code> and the <code>GetAutonomousCommand</code> functions for now, they aren't needed for what we are doing. We'll be focusing exclusively on <code>ConfigureButtonBindings</code>, which is where commands are supposed to be created. Don't worry: we'll show you how to create a command.</p>"},{"location":"tutorials/arcade-drive.html#understanding-subsystems","title":"Understanding Subsystems","text":"<p>So, we now know that most of our code will go in <code>ConfigureButtonBindings</code>, but, what do we write? Before I can answer that, you'll need to very briefly understand subsystems and how they organize code in WPILib.</p> <p>Subsystems are a tool for organizing code on your robot in a way that mirrors the systems present on the robot in the real world. You can think of them like containers for code that all operates one part of the robot, like an arm, or the drivetrain.</p> <p>For instance, you could have a robot that you can break down into its systems:</p> <pre><code>flowchart TD\n\nr[Robot]\nd[Drivetrain]\na[Arm]\nm1[Motor 1]\nm2[Motor 2]\nm3[Motor 3]\nm4[Motor 4]\nm5[Motor 5]\n\nr --&gt; d\nr --&gt; a\n\nd --&gt; m1\nd --&gt; m2\nd --&gt; m3\nd --&gt; m4\n\na --&gt; m5</code></pre> <p>In code, we would neet to support setting the speed of each motor individually accross all subsystems (inside of <code>RobotContainer.cpp</code>):</p> <pre><code>flowchart TD\n\nrc[Robot Container.cpp]\n\nm1[Set Motor 1]\nm2[Set Motor 2]\nm3[Set Motor 3]\nm4[Set Motor 4]\nm5[Set Motor 5]\n\nrc --&gt; m1\nrc --&gt; m2\nrc --&gt; m3\nrc --&gt; m4\nrc --&gt; m5</code></pre> <p>You can see how this would get messy quick in code...</p> <pre><code>// RobotContainer.cpp\n\n// Would have to define 5 functions in order to support each motor\n\nstatic void set_motor_1(float speed)\n{\n  // TODO\n}\n\nstatic void set_motor_2(float speed)\n{\n  // TODO\n}\n\nstatic void set_motor_3(float speed)\n{\n  // TODO\n}\n\nstatic void set_motor_4(float speed)\n{\n  // TODO\n}\n\nstatic void set_motor_5(float speed)\n{\n  // TODO\n}\n</code></pre> <p>To avoid this, we organize our code so that each physical subystem on our robot  (like the drivetrain or arm in the example above) gets its own little box to live in.  In code, these end up being other files. This allows clear seperation between systems: it's easy to tell which motor belongs to which system. Plus, if we  hide the motors away in their own subsystems, we can create functions that are much more readable. Instead of <code>set_motor_5(0.5)</code> we could write: <code>set_arm_speed(0.5)</code> which is much more clear.</p> <p>In our XRP project: we don't have to write any subsystems as one is provided for us. I would encourage you to go take a look at both <code>src/main/cpp/subsystems/Drivetrain.cpp</code> and <code>src/main/cpp/subsystems/Arm.cpp</code>. Both of these subsystems do exactly what I mentioned before, containing all the components for each system in it's own file.</p> <p>Particularly in the header (<code>.h</code>) file: you'll see a function called <code>ArcadeDrive</code>! This function is very similar to what we'll be implementing below.</p>"},{"location":"tutorials/arcade-drive.html#default-commands","title":"Default Commands?","text":"<p>Part of the WPILib command-based robot toolkit is the idea that each subsystem has some default action that it will perform over and over again, as fast as the robot will run. For instance, the drivetrain needs to take data from a controller over and over again and then apply those speeds to the drivetrain, many times a second.</p> <p>This \"default command\" is where we will put our code to actually run the robot.</p> <p>So: how do we start this? Well, firstly we need to access our drivetrain subsystem that lives in <code>Drivetrain.cpp</code> inside of <code>RototContainer.cpp</code>. </p> <p>First: It's important to understand that the <code>Drivetrain</code> subystem is just a C++ class. A consequence of this is that just becuause that <code>Drivetrain.cpp</code> file exists, doesn't mean we have access to it yet in <code>RobotContainer.cpp</code>. <code>Drivetrain.cpp</code> defines what  a drivetrain is and whats inside of it, but we need to go into <code>RobbotContainer.c/h</code> and actually create a drivetrain. You can think of it like this: when you write down a  recipe for a cake, the act of writing down the instructions doesn't create the cake.  You yourself have to follow the instructions to bake the cake to actually make it.  This is analagous to what's going on here between <code>Drivetrain</code> and <code>RobotContainer</code>.</p> <p>You could say that:</p> <pre><code>flowchart TD\n\nr[Robot Container] --&gt;|Depends on| d[Drivetrain]</code></pre> <p>Anyway: default commands. I said just a moment ago that RobotContainer has to  create a drivetrain. Well, if you take a look in <code>RobotContainer.h</code> you can  find out that the <code>Drivetrain</code> object is named <code>m_drive</code>.</p> <p><code>m_drive</code> contains a function called <code>SetDefaultCommand</code> which just tells the subsystem what command to run over and over again as the robot runs. Let's go inside of <code>RobotContainer.cpp</code> and add that:</p> <pre><code>// RobotContainer.cpp (omitting parts of file for simplicity)\n\nvoid RobotContainer::ConfigureButtonBindings() {\n  m_drive.SetDefaultCommand(/* TODO */);\n}\n</code></pre> <p>Just one more step before we can start actually writing our arcade drive code:</p> <pre><code>// RobotContainer.cpp (omitting parts of file for simplicity)\n\nvoid RobotContainer::ConfigureButtonBindings() {\n  m_drive.SetDefaultCommand(frc2::InstantCommand(\n    [this] () {/* our code goes here */}, {&amp;m_drive}\n  ));\n}\n</code></pre> <p>Woah: a lot just happened. Addmitidly, this is a LOT of syntax to swim through at the moment. For now, the technicals behind what is going on here is a little out of scope for this tutorial so just note that:</p> <ul> <li><code>[this] () {}</code> is a C++ lambda, which is just a function we can write in-place where our code will go</li> <li>{&amp;m_drive} is an argument we have to provide to let the command know we are using the <code>m_drive</code> subsystem inside of the function we are about to write.</li> </ul> <p>You can view the function protoytpe for the <code>frc2::InstantCommand</code> here</p>"},{"location":"tutorials/arcade-drive.html#writing-our-drive-code","title":"Writing our Drive Code","text":"<p>Finally: time to write our drive code. First, let's write in psuedo-code using comments what we wnat our drivetrain to do.</p> <pre><code>// RobotContainer.cpp (omitting parts of file for simplicity)\n\nvoid RobotContainer::ConfigureButtonBindings() {\n  m_drive.SetDefaultCommand(frc2::InstantCommand(\n    [this] () {\n\n      // Read joystick left stick up/down\n      // Read joystick right stick left/right\n\n      // Send values to Drivetrain to be used for ArcadeDrive\n\n    }, {&amp;m_drive}\n  ));\n}\n</code></pre> <p>Let's start by reading the joystick. To read a joystick, we'll need to get another object, this time for the x-box controller. For this project, the x-box controller is called <code>m_controller</code> and the function we can use from inside of the controller  to get the joystick axis is: <code>GetRawAxis</code>. This will output a value from -1.0 to 1.0. We'll put these values into a couple variables which we'll use later in the next step.</p> <pre><code>// RobotContainer.cpp (omitting parts of file for simplicity)\n\nvoid RobotContainer::ConfigureButtonBindings() {\n  m_drive.SetDefaultCommand(frc2::InstantCommand(\n    [this] () {\n\n      // TODO: Verify axis indexes\n      double xSpeed = m_controller.GetRawAxis(0);\n      double zRotation = m_controller.GetRawAxis(1);\n\n      // Send values to Drivetrain to be used for ArcadeDrive\n\n    }, {&amp;m_drive}\n  ));\n}\n</code></pre> <p>Variables</p> <p>You'll notice we are assigning the two <code>m_controller.GetRawAxis()</code> calls to variables called <code>xSpeed</code> and <code>zRotation</code> respectively. Variables are just named values in code that we can easily reference. They consist of a  datatype (<code>double</code> in this case, which means a number with a decimal like 0.53) and a name (<code>xSpeed</code> and <code>zRotation</code> in this case). There are other types of variables as well: <code>bool</code>, which holds true/false, <code>int</code> which holds integers, and others. Objects are just special variables with a dataype  that is a class.</p> <p>Now we need to put these values into the drivetrain so it will drive... arcade style. The <code>m_drive</code> object (<code>Drivetrain</code> subsystem) has a function in it called <code>ArcadeDrive</code>. You can see it in the <code>Drivetrain.h</code> file:</p> <pre><code>// Drivetrain.h\n\n/**\n   * Drives the robot using arcade controls.\n   *\n   * @param xaxisSpeed the commanded forward movement\n   * @param zaxisRotate the commanded rotation\n   */\n  void ArcadeDrive(double xaxisSpeed, double zaxisRotate);\n</code></pre> <p>Finding out What Functions Do</p> <p>If you ever want to find out what a function does in a codebase you are working on, you can check the .h file for comments like what we have above that other developers have left to show what the function does.</p> <p>So, we call this function and just have to give the x speed (forward) and  z axis rotation. If you're wondering: WPILib defines the coordinate frame. When working with grid systems, or which way is \"forward\" make sure to always  use WPILib's conventions:</p> <p></p> <pre><code>// RobotContainer.cpp (omitting parts of file for simplicity)\n\nvoid RobotContainer::ConfigureButtonBindings() {\n  m_drive.SetDefaultCommand(frc2::InstantCommand(\n    [this] () {\n\n      // TODO: Verify axis indexes\n      double xSpeed = m_controller.GetRawAxis(0);\n      double zRotation = m_controller.GetRawAxis(1);\n\n      // Send values to Drivetrain to be used for ArcadeDrive\n      m_drive.ArcadeDrive(xSpeed, zRotation);\n    }, {&amp;m_drive}\n  ));\n}\n</code></pre>"},{"location":"tutorials/arcade-drive.html#finish-line","title":"Finish Line \ud83c\udfc3","text":"<p>Well, that's it! We have just made our arcade drive implementation! </p> <p>To get your robot running, you will first have to open your WiFi, and  connect to your XRP robot's WiFi network.</p> <p>After that, go ahead and use the <code>ctrl+shift+p</code> shortcut and type in <code>simulate robot code</code> and select <code>WPILib: Simulate Robot Code</code>, or click on the wpilib icon and select the same command:</p> <p></p> <p>If you're connected to your robot, you should be able to drive it around after your code builds!</p>"},{"location":"tutorials/XRP_Tank_Drive/tutorial_XRP_tank_drive.html","title":"XRP Tank Drive","text":""},{"location":"tutorials/XRP_Tank_Drive/tutorial_XRP_tank_drive.html#xrp-tank-drive-tutorial-c-command-based","title":"XRP Tank Drive Tutorial (C++ Command-Based)","text":"<p>Tank drive is a direct-drive control where one joystick is used for each side of the drive train. The left joystick moves the left motor forward and backward, and the right joystick moves the right motor forward and backward. To turn, you move one joystick forward and the other in reverse. This control scheme offers the driver complete control, but tends to have a steeper learning curve.</p> <p>But, this scheme is the easiest to implement in software because of its simplicity!</p> <p>If you have some experience programming, try implementing this drive control now. Otherwise, read on for step-by-step instructions.</p> <p></p>"},{"location":"tutorials/XRP_Tank_Drive/tutorial_XRP_tank_drive.html#the-pre-code-workout","title":"The Pre-Code Workout \ud83d\udcca","text":"<p>Before we write any code, it's important to make a flow chart of what we need to do, in human readable tasks. When you are solving any problem in software, it's important to do a step like this either in your head, or on paper.</p> <p>Let's start with listing out the tasks we need to perform:</p> <ul> <li>Turn robot left and right</li> <li>Drive forward and back</li> <li>Read left joystick from controller</li> <li>Read right joystick from controller</li> </ul> <p>Now that we have that, let's make a chart of what our code needs to do. Programmers use flow charts a lot to visualize a plan for implementing code.  Try to write your flowchart before looking at the provided one.</p>  Flow Chart \ud83d\udcca <pre><code>flowchart TD\n    a[Read right joystick from controller]\n    b[Read left joystick from controller]\n    c[Set left motor speed]\n    d[Set right motor speed]\n\n    s(start) --&gt; a\n    a --&gt; b\n    b --&gt; c\n    c --&gt; d</code></pre> <p>While simple, it's important to keep the tasks at hand straight. I will walk you through how to do each of these things in code in the next section.</p>"},{"location":"tutorials/XRP_Tank_Drive/tutorial_XRP_tank_drive.html#time-to-start-coding","title":"Time to Start Coding","text":"<p>If you haven't already created an XRP project, you'll need to do that now. See How to Create an XRP Project If you have, it's time to start coding!</p>"},{"location":"tutorials/XRP_Tank_Drive/tutorial_XRP_tank_drive.html#create-a-drivetrain-subsystem","title":"Create a Drivetrain Subsystem","text":"<p>The first step is to create a subsystem for our drivetrain. A subsystem is a class that represents a mechanism on the robot. It should contain all the code for that mechanism, such as motors and sensors.</p> <p>To create a new subsystem in VS Code with the WPILib extension:  1. Right-click on the <code>src/main/include/subsystems</code> folder in the file explorer.  2. Select <code>WPILib: Create a new class/command</code>.  3. Choose <code>Subsystem</code> from the list.  4. Name the new subsystem <code>Drivetrain</code>.  5. You should see two folder now in one in <code>src/main/include/subsystems</code> called <code>Drivetrain.h</code>  and the other in <code>src/main/cpp/subsystems</code> called <code>Drivetrain.cpp</code> </p>"},{"location":"tutorials/XRP_Tank_Drive/tutorial_XRP_tank_drive.html#drivetrainh-header-file","title":"Drivetrain.h header File","text":"<p>What is a Header File in C++?  Imagine you have a big toolbox, and inside it are all the specialized tools (functions and variables) you need to build something.</p> <p>In C++, a header file (usually ending with .h or .hpp) is like a table of contents for a specific part of your toolbox. It doesn't contain the actual tools themselves (the full function definitions or variable storage), but it tells your program:</p> <p>What tools are available: It declares functions, classes, and variables that are defined elsewhere (usually in a corresponding .cpp file). How to use them: It provides the necessary information (like function names, what kind of data they take, and what kind of data they return) so your program knows how to call and interact with these tools. When you use the #include directive (e.g., #include ) at the top of your C++ code, you're essentially telling the compiler, \"Hey, go look at this header file. I plan to use the tools it lists, and I need to know how to use them!\" <p>This helps organize your code, makes it reusable, and allows different parts of your program to know about and use the same functions and data structures without having to redefine them everywhere.</p> <ol> <li>We need to tell the software we want to use the XRP robot motors. To do this we will need to include the header that declares the motor objects, see Controlling a Motor for more details on controlling XRP robot motor.<ol> <li>We will need to add the following include to the top of the <code>Drivetrain.h</code> file <pre><code>#include &lt;frc/xrp/XRPMotor.h&gt;\n</code></pre> br&gt;</li> </ol> </li> <li>Now we need to tell our code about the two motors on the robot. Think of this like giving a name to each motor so we can command it later. In programming, we call these \"objects\". We need one for the left motor and one for the right. The robot knows which is which by a channel number. For the XRP, the left motor is channel <code>0</code> and the right motor is channel <code>1</code>. <ol> <li>Let's add the code to create these motor objects inside our <code>Drivetrain</code> class. We'll put them in the <code>private</code> section of <code>Drivetrain.h</code>. Making them <code>private</code> means only the <code>Drivetrain</code> code can talk to the motors directly, which helps keep our project organized.  <pre><code>private:\n  // This creates an object for the left motor on channel 0\n  frc::XRPMotor m_left_motor{0};\n  // This creates an object for the right motor on channel 1\n  frc::XRPMotor m_right_motor{1};\n</code></pre></li> </ol> </li> <li>Finally, we need to create a way to tell the drivetrain how to move. We'll do this by creating a 'function'. A function is just a named set of instructions. We'll name our function <code>TankDrive</code>. Our <code>TankDrive</code> function needs to know how fast each motor should go, so we'll give it two inputs: <code>leftSpeed</code> and <code>rightSpeed</code>. We need to make this function <code>public</code>, which just means that other parts of the robot's code (like the code for the joystick) are allowed to use it. In the header (<code>.h</code>) file, we just announce that this function exists. This is called a 'declaration'. We'll write the actual instructions for the function in the source (<code>.cpp</code>) file later.     a. Add the function declaration to the <code>public</code> section of <code>Drivetrain.h</code>:      <pre><code>public:\n  // A function to drive the robot with tank-style controls.\n  // It takes a speed for the left side and a speed for the right side.\n  void TankDrive(double leftSpeed, double rightSpeed);\n</code></pre></li> </ol> Your Drivetrain.h file should look like this <pre><code>// Copyright (c) FIRST and other WPILib contributors.\n// Open Source Software; you can modify and/or share it under the terms of\n// the WPILib BSD license file in the root directory of this project.\n\n#pragma once\n\n#include &lt;frc/xrp/XRPMotor.h&gt;\n#include &lt;frc2/command/SubsystemBase.h&gt;\n\nclass Drivetrain : public frc2::SubsystemBase {\n public:\n  Drivetrain();\n\n  // A function to drive the robot with tank-style controls.\n  // It takes a speed for the left side and a speed for the right side.\n  void TankDrive(double leftSpeed, double rightSpeed);\n\n  /**\n   * Will be called periodically whenever the CommandScheduler runs.\n   */\n  void Periodic() override;\n\n private:\n  // Components (e.g. motor controllers and sensors) should generally be\n  // declared private and exposed only through public methods.\n\n  // This creates an object for the left motor on channel 0\n  frc::XRPMotor m_left_motor{0};\n  // This creates an object for the right motor on channel 1\n  frc::XRPMotor m_right_motor{1};\n};\n</code></pre>"},{"location":"tutorials/XRP_Tank_Drive/tutorial_XRP_tank_drive.html#drivetraincpp-source-file","title":"Drivetrain.cpp source File","text":"<p>Now let's look at the <code>Drivetrain.cpp</code> file. If the header (<code>.h</code>) file is the \"table of contents\" for our <code>Drivetrain</code>, the source (<code>.cpp</code>) file is where the actual \"chapters\" are written. This is where we'll write the code that makes our robot do things.</p> <p>Remember how we announced our <code>TankDrive</code> function in the header file? Here in the source file, we will write the actual instructions for it. This is called \"defining\" the function.</p> <ol> <li> <p>Let's write the instructions for our <code>TankDrive</code> function. This is where we tell the motors what to do with the <code>leftSpeed</code> and <code>rightSpeed</code> values we give them.      a. Add the following code to your <code>Drivetrain.cpp</code> file. A good place for it is after the <code>Drivetrain::Periodic()</code> function.      <pre><code>// This is the definition of our TankDrive function.\n// The code inside the curly braces {} is what runs when we call this function.\nvoid Drivetrain::TankDrive(double leftSpeed, double rightSpeed) {\n  // This line tells our left motor object to set its speed to the value of leftSpeed.\n      m_left_motor.Set(leftSpeed);\n  // This line does the same for the right motor, using the rightSpeed value.\n      m_right_motor.Set(rightSpeed);\n}\n</code></pre> What do all those symbols mean?         Just like English has grammar rules, programming languages do too. We call it 'syntax'. Let's look at the syntax for our function, piece by piece.         *   `void Drivetrain::TankDrive(double leftSpeed, double rightSpeed)`             *   Think of this as the function's full name and job description.             *   `void` means \"this function just *does* something, it doesn't give you anything back.\" It's like telling someone \"Go!\" instead of asking \"What time is it?\".             *   `Drivetrain::TankDrive` is the function's full name. `TankDrive` is its first name, and `Drivetrain` is its last name, telling us it belongs to the `Drivetrain` family of code.             *   The part in the parentheses `( ... )` lists the ingredients the function needs to do its job. In this case, it needs two numbers (which can have decimals, called `double`s): one named `leftSpeed` and one named `rightSpeed`.         *   `{ ... }`             *   The curly braces are like the borders of a recipe card. All the instructions for the function go inside them.         *   `m_left_motor.Set(leftSpeed);`             *   This is a single command, like one step in a recipe.             *   `m_left_motor` is the motor we want to talk to.             *   The `.` is like saying \"'s\" in English. So this is like \"the left motor's...\"             *   `Set(leftSpeed)` is the command we are giving it. We're telling it to \"Set your speed to whatever number `leftSpeed` is.\"             *   The `;` at the end is like a period. It tells the computer that this command is finished.   </p> </li> <li> <p>Inverting a Motor. If you were to run the code right now and push both joysticks forward, your robot would probably just spin in a circle.</p> <ul> <li> <p>Why does this happen?</p> </li> <li> <p>Think about the wheels on a toy car. To make it go forward, the wheels on the right side have to spin the opposite way from the wheels on the left side (one spins clockwise, the other counter-clockwise). Our motors are mounted as mirror images of each other, so telling them both to go \"forward\" with a positive speed makes them spin the same way, causing the robot to turn.</p> </li> </ul> </li> <li> <p>How do we fix it?</p> <ul> <li>We need to \"invert\" one of the motors, which just means telling it to do the opposite of what we command. We can do this by simply putting a minus sign <code>-</code> in front of the speed value for one of the motors.</li> </ul> </li> <li> <p>Let's update our <code>TankDrive</code> function to invert the right motor.</p> <p><pre><code>void Drivetrain::TankDrive(double leftSpeed, double rightSpeed) {\n  m_left_motor.Set(leftSpeed);\n  // The minus sign here tells the right motor to spin the opposite way.\n  m_right_motor.Set(-rightSpeed); \n}\n</code></pre>    Now, when you push both joysticks forward, the <code>rightSpeed</code> will be made negative, the right motor will spin in the opposite direction of the left motor, and your robot will drive straight!</p> </li> </ol> Your Drivetrain.cpp file should look like this <pre><code>// Copyright (c) FIRST and other WPILib contributors.\n// Open Source Software; you can modify and/or share it under the terms of\n// the WPILib BSD license file in the root directory of this project.\n\n#include \"subsystems/Drivetrain.h\"\n\nDrivetrain::Drivetrain() = default;\n\n// This is the definition of our TankDrive function.\n// The code inside the curly braces {} is what runs when we call this function.\nvoid Drivetrain::TankDrive(double leftSpeed, double rightSpeed) {\n  // This line tells our left motor object to set its speed to the value of leftSpeed.\n      m_left_motor.Set(leftSpeed);\n  // This line does the same for the right motor, using the rightSpeed value.\n      m_right_motor.Set(-rightSpeed);\n}\n\n// This method will be called once per scheduler run\nvoid Drivetrain::Periodic() {}\n</code></pre>"},{"location":"tutorials/XRP_Tank_Drive/tutorial_XRP_tank_drive.html#robotcontainerh-header-file","title":"RobotContainer.h  header File","text":"<p>What is the Robot Container?</p> <p>Imagine your robot is a person. We've already built the <code>Drivetrain</code>, which is like the robot's legs. We also have a joystick, which is like the robot's ears for hearing commands.</p> <p>The <code>RobotContainer</code> is like the robot's brain. It's the central place where everything gets connected. The brain's job is to:</p> <ol> <li>Know about all the parts: It holds onto our <code>Drivetrain</code> subsystem and our joystick.</li> <li>Connect them: It listens to the joystick (the ears) and tells the <code>Drivetrain</code> (the legs) what to do.</li> </ol> <p>The <code>RobotContainer.h</code> header file is the plan for the brain. It's where we declare all the parts the brain needs to know about, like our <code>Drivetrain</code>, our <code>XboxController</code>, and the <code>RunCommand</code> we'll use to connect them. We're essentially drawing a blueprint of the robot's nervous system.</p> <p>Now let's add our parts to the plan.</p> <ol> <li> <p>First, we need to tell our <code>RobotContainer</code> (the brain) where to find the blueprints for our <code>Drivetrain</code>, our <code>XboxController</code>, and the <code>RunCommand</code> we'll use to connect them. We do this by including their header files at the top of <code>RobotContainer.h</code>. Including a header is like giving the brain the instruction manual for a specific part or tool before it can use it.</p> <pre><code>#include \"subsystems/Drivetrain.h\"\n#include &lt;frc/XboxController.h&gt;\n#include &lt;frc2/command/RunCommand.h&gt;\n</code></pre> </li> <li> <p>Next, we need to create the actual <code>Drivetrain</code> and <code>XboxController</code> objects inside our <code>RobotContainer</code>. Think of this as giving the brain its own set of legs and ears to use. We'll declare these in the <code>private</code> section to keep our code organized. For more details on the controller, see the Xbox Controller section in the WPILib tutorial.</p> <pre><code>private:\n  // Create an instance of our Drivetrain subsystem\n  Drivetrain m_drivetrain;\n\n  // Create an instance of the Xbox Controller on USB port 0\n  frc::XboxController m_controller{0};\n</code></pre> </li> </ol> Your RobotContainer.h file should look like this <pre><code>// Copyright (c) FIRST and other WPILib contributors.\n// Open Source Software; you can modify and/or share it under the terms of\n// the WPILib BSD license file in the root directory of this project.\n\n#pragma once\n\n#include &lt;frc2/command/CommandPtr.h&gt;\n#include &lt;frc2/command/button/CommandXboxController.h&gt;\n\n#include \"Constants.h\"\n#include \"subsystems/ExampleSubsystem.h\"\n\n#include \"subsystems/Drivetrain.h\"\n#include &lt;frc/XboxController.h&gt;\n#include &lt;frc2/command/RunCommand.h&gt;\n\n/**\n * This class is where the bulk of the robot should be declared.  Since\n * Command-based is a \"declarative\" paradigm, very little robot logic should\n * actually be handled in the {@link Robot} periodic methods (other than the\n * scheduler calls).  Instead, the structure of the robot (including subsystems,\n * commands, and trigger mappings) should be declared here.\n */\nclass RobotContainer {\n public:\n  RobotContainer();\n\n  frc2::CommandPtr GetAutonomousCommand();\n\n private:\n  // Replace with CommandPS4Controller or CommandJoystick if needed\n  frc2::CommandXboxController m_driverController{\n      OperatorConstants::kDriverControllerPort};\n\n  // The robot's subsystems are defined here...\n  ExampleSubsystem m_subsystem;\n\n  // Create an instance of our Drivetrain subsystem\n    Drivetrain m_drivetrain;\n\n  // Create an instance of the Xbox Controller on USB port 0\n    frc::XboxController m_controller{0};\n\n  void ConfigureBindings();\n};\n</code></pre>"},{"location":"tutorials/XRP_Tank_Drive/tutorial_XRP_tank_drive.html#robotcontainercpp-source-file","title":"RobotContainer.cpp source File","text":"<p>What is the RobotContainer.cpp file?</p> <p>If the <code>RobotContainer.h</code> file is the plan for the brain, the <code>RobotContainer.cpp</code> file is where the brain actually does its thinking.</p> <p>This is where we write the real instructions that connect the joystick to the drivetrain. We'll write code that essentially says:</p> <p>\"Every moment, check where the joysticks are. Take the value from the left joystick and send it to the left motor. Take the value from the right joystick and send it to the right motor.\"</p> <p>This file brings the plan from the header file to life, creating the real connection between the driver's commands and the robot's movement.</p> <ol> <li> <p>Setting the Drivetrain's Default Job</p> <p>We need to tell the <code>Drivetrain</code> what it should be doing by default: listening to our joysticks. We do this by setting its \"Default Command\". This command will run automatically whenever no other special commands are using the drivetrain.</p> <p>In <code>RobotContainer.cpp</code>, find the <code>ConfigureBindings</code> function. This is where we'll add the code to link the controller to our <code>TankDrive</code> function.</p> <pre><code>  // Set the default command for the drivetrain.\n  // This will run whenever no other command is running on the drivetrain.\n  m_drivetrain.SetDefaultCommand(frc2::RunCommand(\n      [this] {\n        // Drive with tank style\n        m_drivetrain.TankDrive(\n            -m_controller.GetLeftY(),\n            -m_controller.GetRightY());\n      },\n      {&amp;m_drivetrain}));\n</code></pre> <p>What does this code do?  *   It tells the <code>m_drivetrain</code> to run a command by default.  *   The command continuously gets the Y-axis value from the left and right joysticks.  *   It sends those values to our <code>TankDrive</code> function. We use a minus sign (<code>-</code>) because the joystick's Y-axis is inverted (pushing forward gives a negative number).</p> </li> </ol> Let's break down that code syntax   Let's look at that block of code line-by-line. Think of it like giving a set of instructions to a robot chef.   <pre><code>m_drivetrain.SetDefaultCommand(...);\n</code></pre>  *   **This says:** \"Hey Drivetrain, I'm about to give you your default job.\"  *   `m_drivetrain` is our robot's drivetrain.  *   The `.` is like saying \"'s\".  *   `SetDefaultCommand` is the instruction we are giving it. The job we put inside the `()` is what it will do whenever it has nothing else to do.   <pre><code>frc2::RunCommand( ... );\n</code></pre>  *   **This says:** \"The job is a 'Run Command', which means you'll do it over and over, very fast.\"  *   This is a special type of command from the WPILib toolbox that's perfect for things that need constant updates, like reading a joystick.   <pre><code>[this] { ... }\n</code></pre>  *   **This is like a sticky note with instructions.** In C++, it's a \"lambda\"\u2014a small, nameless function.  *   The `{...}` contains the list of steps to do.  *   The `[this]` part is important: it lets the sticky note see and use the other parts of our `RobotContainer`, like the controller.   <pre><code>m_drivetrain.TankDrive(\n   -m_driverController.GetLeftY(),\n   -m_driverController.GetRightY()\n);\n</code></pre>  *   **This is the main instruction on the sticky note.**  *   `m_drivetrain.TankDrive(...)` tells the drivetrain to use the `TankDrive` function we wrote earlier.  *   `-m_driverController.GetLeftY()` gets the position of the **left joystick** (up/down). We use a **minus sign `-`** because pushing the joystick *up* gives a *negative* number, and we need to flip it to be positive for \"forward\".  *   `-m_driverController.GetRightY()` does the exact same thing for the **right joystick**.   <pre><code>{&amp;m_drivetrain}\n</code></pre>  *   **This says:** \"By the way, this job requires the drivetrain.\"  *   This is a note for the robot's main scheduler. It makes sure that no two commands try to use the drivetrain at the exact same time, which would cause chaos.    Your RobotContainer.cpp file should look like this <pre><code>// Copyright (c) FIRST and other WPILib contributors.\n// Open Source Software; you can modify and/or share it under the terms of\n// the WPILib BSD license file in the root directory of this project.\n\n#include \"RobotContainer.h\"\n\n#include &lt;frc2/command/button/Trigger.h&gt;\n\n#include \"commands/Autos.h\"\n#include \"commands/ExampleCommand.h\"\n\nRobotContainer::RobotContainer() {\n  // Initialize all of your commands and subsystems here\n\n  // Configure the button bindings\n  ConfigureBindings();\n}\n\nvoid RobotContainer::ConfigureBindings() {\n  // Configure your trigger bindings here\n\n  // Set the default command for the drivetrain.\n  // This will run whenever no other command is running on the drivetrain.\n  m_drivetrain.SetDefaultCommand(frc2::RunCommand(\n      [this] {\n        // Drive with tank style\n        m_drivetrain.TankDrive(\n            -m_controller.GetLeftY(),\n            -m_controller.GetRightY());\n      },\n      {&amp;m_drivetrain}));\n\n  // Schedule `ExampleCommand` when `exampleCondition` changes to `true`\n  frc2::Trigger([this] {\n    return m_subsystem.ExampleCondition();\n  }).OnTrue(ExampleCommand(&amp;m_subsystem).ToPtr());\n\n  // Schedule `ExampleMethodCommand` when the Xbox controller's B button is\n  // pressed, cancelling on release.\n  m_driverController.B().WhileTrue(m_subsystem.ExampleMethodCommand());\n}\n\nfrc2::CommandPtr RobotContainer::GetAutonomousCommand() {\n  // An example command will be run in autonomous\n  return autos::ExampleAuto(&amp;m_subsystem);\n}\n</code></pre>"},{"location":"tutorials/XRP_Tank_Drive/tutorial_XRP_tank_drive.html#time-to-test-your-code","title":"Time to test your code","text":"<p>Great job writing your first XRP code.  it is time to test your code.  Go to XRP Run Code to test your code</p>"},{"location":"tutorials/XRP_WPILib/tutorial_XRP_WPILib.html","title":"XRP WPILib Overview","text":""},{"location":"tutorials/XRP_WPILib/tutorial_XRP_WPILib.html#xrp-wpilib-overview","title":"XRP WPILib Overview","text":"<p>WPILib is like a special toolbox for C++ programmers in FIRST Robotics. It gives you ready-made tools to control your robot's motors, read sensors, and talk to the drivers. It makes programming your robot much easier, so you can focus on making it do cool things instead of worrying about tiny details.</p> <p>for official documentation go to WPILib 2025</p>"},{"location":"tutorials/XRP_WPILib/tutorial_XRP_WPILib.html#controlling-a-motor","title":"Controlling a Motor","text":"<p>The XRP robot has two motors: a left and a right drive motor. The motor speed range is from -1.0 to 1.0.</p> <p>For more details, see the WPILib XRPMotor Class Reference.</p> <p>The motor IDs are as follows: 1. Left Motor: ID 0 2. Right Motor: ID 1 3. Open Motor 1: ID 2 4. Open Motor 2: ID 3  </p> <p>To use the <code>XRPMotor</code> class, you need to include its header file:</p> <pre><code>#include &lt;frc/xrp/XRPMotor.h&gt;\n</code></pre> <p>Constructor</p> <p>You create an <code>XRPMotor</code> object by specifying its device ID (0 for the left motor, 1 for the right motor).</p> <pre><code>// Create motor objects for both left and right motors\nfrc::XRPMotor m_left_motor{0};\nfrc::XRPMotor m_right_motor{1};\n</code></pre> <p>Common Methods</p> <ul> <li><code>Set(double speed)</code>: Sets the motor speed, from -1.0 (full reverse) to 1.0 (full forward).</li> <li><code>SetInverted(bool isInverted)</code>: Inverts the direction of the motor. This is useful for drivetrains where motors on opposite sides need to spin in opposite directions to drive forward.</li> <li><code>Get()</code>: Returns the last speed set to the motor.</li> </ul> <p>Usage Example</p> <p>This example shows how to set up and control the motors for a simple differential drive.</p> <pre><code>// Invert the right motor so both motors spin in the same direction for forward motion\nm_right_motor.SetInverted(true);\n\n// Drive forward at half speed\nm_left_motor.Set(0.5);\nm_right_motor.Set(0.5);\n</code></pre>"},{"location":"tutorials/XRP_WPILib/tutorial_XRP_WPILib.html#xbox-controller","title":"Xbox Controller","text":"<p>To control the robot with a gamepad, you can use the <code>frc::XboxController</code> class. This class provides an easy way to read the state of all buttons and joysticks.</p> <p>For more details, see the WPILib XboxController Class Reference.</p> <p>To use the <code>XboxController</code> class, you need to include its header file:</p> <pre><code>#include &lt;frc/XboxController.h&gt;\n</code></pre> <p>Constructor</p> <p>You need to create an <code>XboxController</code> object, specifying the USB port it's connected to on the driver station (usually <code>0</code> for the primary controller).</p> <pre><code>// Create a controller object on port 0\nfrc::XboxController m_controller{0};\n</code></pre> <p>Button Mappings</p> <p>The buttons are accessed using methods that return <code>true</code> if the button is currently pressed.</p> <ul> <li>A Button: <code>GetAButton()</code></li> <li>B Button: <code>GetBButton()</code></li> <li>X Button: <code>GetXButton()</code></li> <li>Y Button: <code>GetYButton()</code></li> <li>Left Bumper: <code>GetLeftBumper()</code></li> <li>Right Bumper: <code>GetRightBumper()</code></li> <li>Back Button: <code>GetBackButton()</code></li> <li>Start Button: <code>GetStartButton()</code></li> <li>Left Stick Button: <code>GetLeftStickButton()</code></li> <li>Right Stick Button: <code>GetRightStickButton()</code></li> </ul> <p>Axis Mappings</p> <p>The axes (joysticks and triggers) return values from -1.0 to 1.0. Note that for the joysticks, the Y-axis is inverted (pushing up gives a negative value).</p> <ul> <li>Left Stick X-Axis: <code>GetLeftX()</code></li> <li>Left Stick Y-Axis: <code>GetLeftY()</code></li> <li>Right Stick X-Axis: <code>GetRightX()</code></li> <li>Right Stick Y-Axis: <code>GetRightY()</code></li> <li>Left Trigger: <code>GetLeftTriggerAxis()</code> (range: 0.0 to 1.0)</li> <li>Right Trigger: <code>GetRightTriggerAxis()</code> (range: 0.0 to 1.0)</li> </ul> <p>Usage Example</p> <p>This example shows how to use the left joystick's Y-axis to control the speed of the left motor.</p> <pre><code>// Get the Y-axis value from the left joystick (-1.0 to 1.0).\ndouble left_y_position = m_controller.GetLeftY();\n\n// Set the motor speed using the joystick value. The value is negated \n// because GetLeftY() is inverted by default.\nm_left_motor.Set(-left_y_position);\n\n// GetAButton() returns a boolean (true if pressed).\nbool a_button_pressed = m_controller.GetAButton();\n</code></pre>"},{"location":"tutorials/XRP_WPILib/tutorial_XRP_WPILib.html#unit-library","title":"Unit Library","text":"<p>The WPILib units library is a powerful tool that provides compile-time type safety for physical units. This prevents common programming errors, such as accidentally adding a distance to a time. Many modern WPILib functions, especially for sensors and mechanisms, use this library.</p> <p>For more details, see the WPILib Units Library Documentation.</p> <p>Using the Library</p> <p>To use a specific unit, you must include its corresponding header file.</p> <pre><code>#include &lt;units/length.h&gt;\n#include &lt;units/angle.h&gt;\n#include &lt;units/time.h&gt;\n</code></pre> <p>Literals</p> <p>The library provides convenient literals for creating unit-based values. You simply append the literal to a number.</p> <ul> <li>Length: <code>_m</code> (meters), <code>_ft</code> (feet), <code>_in</code> (inches)</li> <li>Angle: <code>_deg</code> (degrees), <code>_rad</code> (radians)</li> <li>Time: <code>_s</code> (seconds), <code>_ms</code> (milliseconds)</li> </ul> <p>Usage Example</p> <p>This example demonstrates declaring unit-based variables and performing conversions.</p> <pre><code>// Declare a variable to hold a distance in meters\nunits::meter_t distance = 1.5_m;\n\n// The library automatically handles conversions between compatible types\nunits::inch_t distance_in_inches = distance; // distance_in_inches is now ~59.055\n\n// This line would cause a compiler error because the units are incompatible\n// auto error = 5.0_m + 2.0_s; \n</code></pre> <p>As seen in the Gyro and Servo sections, you'll use types like <code>units::degree_t</code> when interacting with those devices.</p>"},{"location":"tutorials/XRP_WPILib/tutorial_XRP_WPILib.html#write-to-command-window","title":"Write to command window","text":"<p>Writing information to the command window (or console) is a fundamental tool for debugging your robot code. You can print simple text messages or the values of variables to understand what your program is doing in real-time. The output will appear in the \"WPILib Console\" in VS Code when running the simulator or deploying to the robot.</p> <p>A common way to do this in C++ is with <code>std::cout</code> from the <code>&lt;iostream&gt;</code> library. For more detailed information, see the C++ documentation for std::cout.</p> <p>Setup</p> <p>To use <code>std::cout</code>, you need to include the necessary header file:</p> <pre><code>#include &lt;iostream&gt;\n</code></pre> <p>Common Methods</p> <ul> <li><code>std::cout &lt;&lt; ...</code>: The stream insertion operator is used to send data (text, variables) to the console. You can chain multiple <code>&lt;&lt;</code> operators together to print a sequence of items.</li> <li><code>std::endl</code> or <code>'\\n'</code>: Both are used to insert a newline character at the end of your output.</li> </ul> <p>Usage Example</p> <p>This example shows how to read the Y-axis of the left joystick and print its value to the console. This is useful for seeing sensor or controller values live.</p> <pre><code>// This code assumes an `m_controller` object has already been created.\n\n// Get the Y-axis value from the left joystick (-1.0 to 1.0).\ndouble left_y_position = m_controller.GetLeftY();\n\n// Print the value to the console\nstd::cout &lt;&lt; \"Left Joystick Y: \" &lt;&lt; left_y_position &lt;&lt; std::endl;\n\n// The output in the console might look like:\n// Left Joystick Y: -0.753\n</code></pre>"},{"location":"tutorials/XRP_WPILib/tutorial_XRP_WPILib.html#smart-dashboard-work-in-progress","title":"Smart Dashboard (Work in progress)","text":"<p>While printing to the command window is useful, the SmartDashboard provides a powerful graphical user interface (GUI) for interacting with your robot. It allows you to display multiple sensor values at once, plot data over time, and even add simple controls. This is the preferred method when you need to visualize how values are changing or monitor many outputs simultaneously.</p> <p>For more details, see the WPILib SmartDashboard Documentation.</p> <p>Setup</p> <p>To use the SmartDashboard, you need to include its header file:</p> <pre><code>#include &lt;frc/smartdashboard/SmartDashboard.h&gt;\n</code></pre> <p>Common Methods</p> <p>Data is sent to the SmartDashboard using key-value pairs. The <code>key</code> is a string that will be the label for the data in the GUI.</p> <ul> <li><code>frc::SmartDashboard::PutNumber(std::string_view key, double value)</code>: Displays a number on the dashboard.</li> <li><code>frc::SmartDashboard::PutBoolean(std::string_view key, bool value)</code>: Displays a boolean as a true/false indicator.</li> <li><code>frc::SmartDashboard::PutString(std::string_view key, std::string_view value)</code>: Displays a text string.</li> </ul> <p>Usage Example</p> <p>This example shows how to send the gyro angle and a button state to the SmartDashboard.</p> <pre><code>// This code assumes m_gyro and m_controller objects have been created.\n\n// Get values from sensors and controllers\nunits::degree_t angle = m_gyro.GetAngle();\nbool a_button_pressed = m_controller.GetAButton();\n\n// Send the values to the SmartDashboard with descriptive keys\nfrc::SmartDashboard::PutNumber(\"Gyro Angle (deg)\", angle.value());\nfrc::SmartDashboard::PutBoolean(\"A Button Pressed\", a_button_pressed);\n</code></pre> <p>When you run the robot code, you can launch the SmartDashboard from the WPILib command palette in VS Code. The values will appear with their labels. You can right-click on a numeric value and choose to display it as a graph to plot it over time.</p>"},{"location":"tutorials/XRP_WPILib/tutorial_XRP_WPILib.html#gyro","title":"Gyro","text":"<p>The XRP has an onboard gyroscope that can be used to measure the robot's heading (rotation). This is useful for making precise turns or driving straight.</p> <p>For more details, see the WPILib XRPGyro Class Reference.</p> <p>To use the <code>XRPGyro</code> class, you need to include the <code>XRPGyro</code> and <code>units</code> header files:</p> <pre><code>#include &lt;frc/xrp/XRPGyro.h&gt;\n#include &lt;units/angle.h&gt;\n#include &lt;iostream&gt;\n</code></pre> <p>Constructor</p> <p>You can construct an <code>XRPGyro</code> object without any parameters.</p> <pre><code>frc::XRPGyro m_gyro;\n</code></pre> <p>Common Methods</p> <ul> <li><code>GetAngle()</code>: Returns the accumulated angle as a <code>units::degree_t</code>. Clockwise rotation is positive.</li> <li><code>Reset()</code>: Resets the gyro's angle to 0. This is useful for setting a new \"forward\" direction.</li> </ul> <p>Usage Example</p> <p>This example shows how to read the gyro's angle and print it to the console.</p> <pre><code>// Reset the gyro's current angle to 0\nm_gyro.Reset();\n\n// Get the current angle of the robot\nunits::degree_t current_angle = m_gyro.GetAngle();\n\n// Print the angle to the console. .value() is used to get the raw number.\nstd::cout &lt;&lt; \"Gyro Angle: \" &lt;&lt; current_angle.value() &lt;&lt; \" deg\" &lt;&lt; std::endl;\n</code></pre>"},{"location":"tutorials/XRP_WPILib/tutorial_XRP_WPILib.html#servo","title":"Servo","text":"<p>The XRP robot has two dedicated ports for standard hobby servos. These are controlled using the specific <code>frc::XRPServo</code> class, which allows for precise control of angular position (typically 0-180 degrees).</p> <p>For more details, see the WPILib XRPServo Class Reference.</p> <p>To use a servo, you need to include the <code>XRPServo</code> and <code>units</code> header files:</p> <pre><code>#include &lt;frc/xrp/XRPServo.h&gt;\n#include &lt;units/angle.h&gt;\n#include &lt;iostream&gt;\n</code></pre> <p>Constructor</p> <p>You create an <code>XRPServo</code> object by specifying its device number. The XRP has two servo ports:</p> <ul> <li>Servo 1: Device Number 0</li> <li>Servo 2: Device Number 1</li> </ul> <pre><code>// Create a servo object for the servo connected to port 1 on the XRP\nfrc::XRPServo m_servo1{0};\n</code></pre> <p>Common Methods</p> <ul> <li><code>SetAngle(units::degree_t angle)</code>: Sets the servo's angle. The valid range is typically 0 to 180 degrees.</li> <li><code>GetAngle()</code>: Returns the last angle set for the servo as a <code>units::degree_t</code>.</li> </ul> <p>Usage Example</p> <p>This example shows how to set a servo's angle and then read it back.</p> <pre><code>// Set the servo to its midpoint\nm_servo1.SetAngle(90.0_deg);\n\n// Read the angle back from the servo\nunits::degree_t current_angle = m_servo1.GetAngle();\n\n// Print the angle to the console\nstd::cout &lt;&lt; \"Servo Angle: \" &lt;&lt; current_angle.value() &lt;&lt; \" deg\" &lt;&lt; std::endl;\n</code></pre>"},{"location":"tutorials/XRP_WPILib/tutorial_XRP_WPILib.html#line-sensor","title":"Line Sensor","text":"<p>The XRP has an onboard reflectance sensor array for line following. This is managed by the <code>frc::XRPReflectanceSensor</code> class, which provides readings from the left and right sensors.</p> <p>For more details, see the WPILib XRPReflectanceSensor Class Reference.</p> <p>To use the line sensor, you need to include the <code>XRPReflectanceSensor</code> header file:</p> <pre><code>#include &lt;frc/xrp/XRPReflectanceSensor.h&gt;\n#include &lt;iostream&gt;\n</code></pre> <p>Constructor</p> <p>You can construct an <code>XRPReflectanceSensor</code> object without any parameters. It automatically handles both the left and right sensors.</p> <pre><code>// Create an object for the reflectance sensor array\nfrc::XRPReflectanceSensor m_reflectance_sensor;\n</code></pre> <p>Common Methods</p> <ul> <li><code>GetLeftValue()</code>: Returns the left sensor's reflectance value as a <code>double</code> from 0.0 (light) to 1.0 (dark).</li> <li><code>GetRightValue()</code>: Returns the right sensor's reflectance value as a <code>double</code> from 0.0 (light) to 1.0 (dark).</li> </ul> <p>Usage Example</p> <p>This example shows how to read the values from both sensors and print them.</p> <pre><code>// Read the values from the left and right sensors\ndouble left_value = m_reflectance_sensor.GetLeftValue();\ndouble right_value = m_reflectance_sensor.GetRightValue();\n\n// Print the values to the console\nstd::cout &lt;&lt; \"Left Sensor: \" &lt;&lt; left_value &lt;&lt; \", Right Sensor: \" &lt;&lt; right_value &lt;&lt; std::endl;\n</code></pre>"},{"location":"tutorials/XRP_project/tutorial_XRP_Project.html","title":"Creating a C++ XRP Project","text":"<p>This tutorial details how to create a blank C++ XRP project using the command-based framework. For a more in-depth overview, please refer to the WPILib documentation.</p>"},{"location":"tutorials/XRP_project/tutorial_XRP_Project.html#project-creation-steps","title":"Project Creation Steps","text":"<ol> <li> <p>Open WPILib VS Code. If you do not have this, see the WPILib Installation Guide.  </p> </li> <li> <p>Click the WPILib icon.</p> <ol> <li>WPILib icon is in the upper-right corner.</li> <li> </li> </ol> </li> <li> <p>In the prompt window, type \"New Project\" and click \"WPILib: Create a new project\".</p> <ol> <li> </li> </ol> </li> <li> <p>A window like this will appear: </p> <ol> <li> </li> </ol> </li> <li> <p>Click \"Select a project type (Example or Template)\". </p> </li> <li> <p>A prompt window will appear. Select \"Template\" -&gt; \"C++\" -&gt; \"XRP - Command Robot\".</p> <ol> <li> </li> </ol> </li> <li> <p>Select a folder for your project.  </p> </li> <li> <p>For Project Name: Argos Tutorial. </p> </li> <li> <p>For Team number: 1756. </p> </li> <li> <p>\u26a0\ufe0f Important: Enable Desktop Support</p> <ol> <li>You must click the checkbox to Enable Desktop Support. This is critical for running the simulator.</li> <li> </li> </ol> </li> <li> <p>Click \"Generate Project\".</p> <ol> <li> </li> </ol> </li> <li> <p>Click \"Yes (Current Window)\".</p> <ol> <li>This will open the project you just created.</li> <li> </li> </ol> </li> <li> <p>It should open a file structure that looks like this.</p> <ol> <li> </li> </ol> </li> <li> <p>Congratulations!  You have created an empty project.</p> </li> </ol>"},{"location":"summer-robot-2025/annotated.html","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class Robot </li> <li>class RobotContainer </li> <li>class Telemetry </li> <li>class TunerConstants </li> <li>class TunerSwerveDrivetrain Swerve Drive class utilizing CTR Electronics' Phoenix 6 API with the selected device types. </li> <li>namespace phoenix6 </li> <li>namespace frc </li> <li>namespace frc2 </li> <li>namespace speeds <ul> <li>namespace drive </li> </ul> </li> <li>namespace subsystems <ul> <li>class CommandSwerveDrivetrain Class that extends the Phoenix 6 SwerveDrivetrain class and implements Subsystem so it can easily be used in command-based projects. </li> </ul> </li> <li>namespace swerve </li> </ul>"},{"location":"summer-robot-2025/files.html","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir src <ul> <li>dir main <ul> <li>dir cpp <ul> <li>file Robot.cpp </li> <li>file RobotContainer.cpp </li> <li>file Telemetry.cpp </li> <li>dir generated <ul> <li>file TunerConstants.cpp </li> </ul> </li> <li>dir subsystems <ul> <li>file CommandSwerveDrivetrain.cpp </li> </ul> </li> </ul> </li> <li>dir include <ul> <li>file Constants.h </li> <li>file Robot.h </li> <li>file RobotContainer.h </li> <li>file Telemetry.h </li> <li>dir generated <ul> <li>file TunerConstants.h </li> </ul> </li> <li>dir subsystems <ul> <li>file CommandSwerveDrivetrain.h </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"summer-robot-2025/classRobot.html","title":"Class Robot","text":"<p>ClassList &gt; Robot</p> <p>Inherits the following classes: frc::TimedRobot</p>"},{"location":"summer-robot-2025/classRobot.html#public-functions","title":"Public Functions","text":"Type Name void AutonomousExit () override void AutonomousInit () override void AutonomousPeriodic () override void DisabledExit () override void DisabledInit () override void DisabledPeriodic () override Robot ()  void RobotPeriodic () override void TeleopExit () override void TeleopInit () override void TeleopPeriodic () override void TestExit () override void TestInit () override void TestPeriodic () override"},{"location":"summer-robot-2025/classRobot.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"summer-robot-2025/classRobot.html#function-autonomousexit","title":"function AutonomousExit","text":"<pre><code>void Robot::AutonomousExit () override\n</code></pre>"},{"location":"summer-robot-2025/classRobot.html#function-autonomousinit","title":"function AutonomousInit","text":"<pre><code>void Robot::AutonomousInit () override\n</code></pre>"},{"location":"summer-robot-2025/classRobot.html#function-autonomousperiodic","title":"function AutonomousPeriodic","text":"<pre><code>void Robot::AutonomousPeriodic () override\n</code></pre>"},{"location":"summer-robot-2025/classRobot.html#function-disabledexit","title":"function DisabledExit","text":"<pre><code>void Robot::DisabledExit () override\n</code></pre>"},{"location":"summer-robot-2025/classRobot.html#function-disabledinit","title":"function DisabledInit","text":"<pre><code>void Robot::DisabledInit () override\n</code></pre>"},{"location":"summer-robot-2025/classRobot.html#function-disabledperiodic","title":"function DisabledPeriodic","text":"<pre><code>void Robot::DisabledPeriodic () override\n</code></pre>"},{"location":"summer-robot-2025/classRobot.html#function-robot","title":"function Robot","text":"<pre><code>Robot::Robot () \n</code></pre>"},{"location":"summer-robot-2025/classRobot.html#function-robotperiodic","title":"function RobotPeriodic","text":"<pre><code>void Robot::RobotPeriodic () override\n</code></pre>"},{"location":"summer-robot-2025/classRobot.html#function-teleopexit","title":"function TeleopExit","text":"<pre><code>void Robot::TeleopExit () override\n</code></pre>"},{"location":"summer-robot-2025/classRobot.html#function-teleopinit","title":"function TeleopInit","text":"<pre><code>void Robot::TeleopInit () override\n</code></pre>"},{"location":"summer-robot-2025/classRobot.html#function-teleopperiodic","title":"function TeleopPeriodic","text":"<pre><code>void Robot::TeleopPeriodic () override\n</code></pre>"},{"location":"summer-robot-2025/classRobot.html#function-testexit","title":"function TestExit","text":"<pre><code>void Robot::TestExit () override\n</code></pre>"},{"location":"summer-robot-2025/classRobot.html#function-testinit","title":"function TestInit","text":"<pre><code>void Robot::TestInit () override\n</code></pre>"},{"location":"summer-robot-2025/classRobot.html#function-testperiodic","title":"function TestPeriodic","text":"<pre><code>void Robot::TestPeriodic () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/main/include/Robot.h</code></p>"},{"location":"summer-robot-2025/classRobotContainer.html","title":"Class RobotContainer","text":"<p>ClassList &gt; RobotContainer</p>"},{"location":"summer-robot-2025/classRobotContainer.html#public-attributes","title":"Public Attributes","text":"Type Name subsystems::CommandSwerveDrivetrain drivetrain   = <code>{[**TunerConstants::CreateDrivetrain**](classTunerConstants.md#function-createdrivetrain)()}</code>"},{"location":"summer-robot-2025/classRobotContainer.html#public-functions","title":"Public Functions","text":"Type Name frc2::CommandPtr GetAutonomousCommand ()  RobotContainer ()"},{"location":"summer-robot-2025/classRobotContainer.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"summer-robot-2025/classRobotContainer.html#variable-drivetrain","title":"variable drivetrain","text":"<pre><code>subsystems::CommandSwerveDrivetrain RobotContainer::drivetrain;\n</code></pre>"},{"location":"summer-robot-2025/classRobotContainer.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"summer-robot-2025/classRobotContainer.html#function-getautonomouscommand","title":"function GetAutonomousCommand","text":"<pre><code>frc2::CommandPtr RobotContainer::GetAutonomousCommand () \n</code></pre>"},{"location":"summer-robot-2025/classRobotContainer.html#function-robotcontainer","title":"function RobotContainer","text":"<pre><code>RobotContainer::RobotContainer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/main/include/RobotContainer.h</code></p>"},{"location":"summer-robot-2025/classTelemetry.html","title":"Class Telemetry","text":"<p>ClassList &gt; Telemetry</p>"},{"location":"summer-robot-2025/classTelemetry.html#public-functions","title":"Public Functions","text":"Type Name void Telemeterize (subsystems::CommandSwerveDrivetrain::SwerveDriveState const &amp; state)  Telemetry (units::meters_per_second_t maxSpeed)"},{"location":"summer-robot-2025/classTelemetry.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"summer-robot-2025/classTelemetry.html#function-telemeterize","title":"function Telemeterize","text":"<pre><code>void Telemetry::Telemeterize (\n    subsystems::CommandSwerveDrivetrain::SwerveDriveState const &amp; state\n) \n</code></pre> <p>Accept the swerve drive state and telemeterize it to SmartDashboard and SignalLogger. </p>"},{"location":"summer-robot-2025/classTelemetry.html#function-telemetry","title":"function Telemetry","text":"<pre><code>Telemetry::Telemetry (\n    units::meters_per_second_t maxSpeed\n) \n</code></pre> <p>Construct a telemetry object with the specified max speed of the robot.</p> <p>Parameters:</p> <ul> <li><code>maxSpeed</code> Maximum speed </li> </ul> <p>The documentation for this class was generated from the following file <code>src/main/include/Telemetry.h</code></p>"},{"location":"summer-robot-2025/classTunerConstants.html","title":"Class TunerConstants","text":"<p>ClassList &gt; TunerConstants</p>"},{"location":"summer-robot-2025/classTunerConstants.html#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr swerve::SwerveModuleConstants BackLeft   = <code>/* multi line expression */</code> constexpr swerve::SwerveModuleConstants BackRight   = <code>/* multi line expression */</code> constexpr swerve::SwerveDrivetrainConstants DrivetrainConstants   = <code>/* multi line expression */</code> constexpr swerve::SwerveModuleConstants FrontLeft   = <code>/* multi line expression */</code> constexpr swerve::SwerveModuleConstants FrontRight   = <code>/* multi line expression */</code> const CANBus kCANBus   = <code>{kCANBusName, \"./logs/example.hoot\"}</code> constexpr units::meters_per_second_t kSpeedAt12Volts   = <code>5.21\\_mps</code>"},{"location":"summer-robot-2025/classTunerConstants.html#public-static-functions","title":"Public Static Functions","text":"Type Name subsystems::CommandSwerveDrivetrain CreateDrivetrain ()"},{"location":"summer-robot-2025/classTunerConstants.html#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"summer-robot-2025/classTunerConstants.html#variable-backleft","title":"variable BackLeft","text":"<pre><code>constexpr swerve::SwerveModuleConstants TunerConstants::BackLeft;\n</code></pre>"},{"location":"summer-robot-2025/classTunerConstants.html#variable-backright","title":"variable BackRight","text":"<pre><code>constexpr swerve::SwerveModuleConstants TunerConstants::BackRight;\n</code></pre>"},{"location":"summer-robot-2025/classTunerConstants.html#variable-drivetrainconstants","title":"variable DrivetrainConstants","text":"<pre><code>constexpr swerve::SwerveDrivetrainConstants TunerConstants::DrivetrainConstants;\n</code></pre>"},{"location":"summer-robot-2025/classTunerConstants.html#variable-frontleft","title":"variable FrontLeft","text":"<pre><code>constexpr swerve::SwerveModuleConstants TunerConstants::FrontLeft;\n</code></pre>"},{"location":"summer-robot-2025/classTunerConstants.html#variable-frontright","title":"variable FrontRight","text":"<pre><code>constexpr swerve::SwerveModuleConstants TunerConstants::FrontRight;\n</code></pre>"},{"location":"summer-robot-2025/classTunerConstants.html#variable-kcanbus","title":"variable kCANBus","text":"<pre><code>const CANBus TunerConstants::kCANBus;\n</code></pre>"},{"location":"summer-robot-2025/classTunerConstants.html#variable-kspeedat12volts","title":"variable kSpeedAt12Volts","text":"<pre><code>constexpr units::meters_per_second_t TunerConstants::kSpeedAt12Volts;\n</code></pre>"},{"location":"summer-robot-2025/classTunerConstants.html#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"summer-robot-2025/classTunerConstants.html#function-createdrivetrain","title":"function CreateDrivetrain","text":"<pre><code>static subsystems::CommandSwerveDrivetrain TunerConstants::CreateDrivetrain () \n</code></pre> <p>Creates a CommandSwerveDrivetrain instance. This should only be called once in your robot program. </p> <p>The documentation for this class was generated from the following file <code>src/main/include/generated/TunerConstants.h</code></p>"},{"location":"summer-robot-2025/classTunerSwerveDrivetrain.html","title":"Class TunerSwerveDrivetrain","text":"<p>ClassList &gt; TunerSwerveDrivetrain</p> <p>Swerve Drive class utilizing CTR Electronics' Phoenix 6 API with the selected device types. </p> <ul> <li><code>#include &lt;TunerConstants.h&gt;</code></li> </ul> <p>Inherits the following classes: swerve::SwerveDrivetrain&lt; hardware::TalonFX, hardware::TalonFX, hardware::CANcoder &gt;</p> <p>Inherited by the following classes: subsystems::CommandSwerveDrivetrain</p>"},{"location":"summer-robot-2025/classTunerSwerveDrivetrain.html#public-types","title":"Public Types","text":"Type Name typedef swerve::SwerveModuleConstants&lt; configs::TalonFXConfiguration, configs::TalonFXConfiguration, configs::CANcoderConfiguration &gt; SwerveModuleConstants"},{"location":"summer-robot-2025/classTunerSwerveDrivetrain.html#public-functions","title":"Public Functions","text":"Type Name TunerSwerveDrivetrain (swerve::SwerveDrivetrainConstants const &amp; driveTrainConstants, ModuleConstants const &amp;... modules) Constructs a CTRE SwerveDrivetrain using the specified constants. TunerSwerveDrivetrain (swerve::SwerveDrivetrainConstants const &amp; driveTrainConstants, units::hertz_t odometryUpdateFrequency, ModuleConstants const &amp;... modules) Constructs a CTRE SwerveDrivetrain using the specified constants. TunerSwerveDrivetrain (swerve::SwerveDrivetrainConstants const &amp; driveTrainConstants, units::hertz_t odometryUpdateFrequency, std::array&lt; double, 3 &gt; const &amp; odometryStandardDeviation, std::array&lt; double, 3 &gt; const &amp; visionStandardDeviation, ModuleConstants const &amp;... modules) Constructs a CTRE SwerveDrivetrain using the specified constants."},{"location":"summer-robot-2025/classTunerSwerveDrivetrain.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"summer-robot-2025/classTunerSwerveDrivetrain.html#typedef-swervemoduleconstants","title":"typedef SwerveModuleConstants","text":"<pre><code>using TunerSwerveDrivetrain::SwerveModuleConstants =  swerve::SwerveModuleConstants&lt;configs::TalonFXConfiguration, configs::TalonFXConfiguration, configs::CANcoderConfiguration&gt;;\n</code></pre>"},{"location":"summer-robot-2025/classTunerSwerveDrivetrain.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"summer-robot-2025/classTunerSwerveDrivetrain.html#function-tunerswervedrivetrain-13","title":"function TunerSwerveDrivetrain [1/3]","text":"<p>Constructs a CTRE SwerveDrivetrain using the specified constants. <pre><code>template&lt;std::same_as&lt; SwerveModuleConstants &gt;... ModuleConstants&gt;\ninline TunerSwerveDrivetrain::TunerSwerveDrivetrain (\n    swerve::SwerveDrivetrainConstants const &amp; driveTrainConstants,\n    ModuleConstants const &amp;... modules\n) \n</code></pre></p> <p>This constructs the underlying hardware devices, so users should not construct the devices themselves. If they need the devices, they can access them through getters in the classes.</p> <p>Parameters:</p> <ul> <li><code>drivetrainConstants</code> Drivetrain-wide constants for the swerve drive </li> <li><code>modules</code> Constants for each specific module </li> </ul>"},{"location":"summer-robot-2025/classTunerSwerveDrivetrain.html#function-tunerswervedrivetrain-23","title":"function TunerSwerveDrivetrain [2/3]","text":"<p>Constructs a CTRE SwerveDrivetrain using the specified constants. <pre><code>template&lt;std::same_as&lt; SwerveModuleConstants &gt;... ModuleConstants&gt;\ninline TunerSwerveDrivetrain::TunerSwerveDrivetrain (\n    swerve::SwerveDrivetrainConstants const &amp; driveTrainConstants,\n    units::hertz_t odometryUpdateFrequency,\n    ModuleConstants const &amp;... modules\n) \n</code></pre></p> <p>This constructs the underlying hardware devices, so users should not construct the devices themselves. If they need the devices, they can access them through getters in the classes.</p> <p>Parameters:</p> <ul> <li><code>drivetrainConstants</code> Drivetrain-wide constants for the swerve drive </li> <li><code>odometryUpdateFrequency</code> The frequency to run the odometry loop. If unspecified or set to 0 Hz, this is 250 Hz on CAN FD, and 100 Hz on CAN 2.0. </li> <li><code>modules</code> Constants for each specific module </li> </ul>"},{"location":"summer-robot-2025/classTunerSwerveDrivetrain.html#function-tunerswervedrivetrain-33","title":"function TunerSwerveDrivetrain [3/3]","text":"<p>Constructs a CTRE SwerveDrivetrain using the specified constants. <pre><code>template&lt;std::same_as&lt; SwerveModuleConstants &gt;... ModuleConstants&gt;\ninline TunerSwerveDrivetrain::TunerSwerveDrivetrain (\n    swerve::SwerveDrivetrainConstants const &amp; driveTrainConstants,\n    units::hertz_t odometryUpdateFrequency,\n    std::array&lt; double, 3 &gt; const &amp; odometryStandardDeviation,\n    std::array&lt; double, 3 &gt; const &amp; visionStandardDeviation,\n    ModuleConstants const &amp;... modules\n) \n</code></pre></p> <p>This constructs the underlying hardware devices, so users should not construct the devices themselves. If they need the devices, they can access them through getters in the classes.</p> <p>Parameters:</p> <ul> <li><code>drivetrainConstants</code> Drivetrain-wide constants for the swerve drive </li> <li><code>odometryUpdateFrequency</code> The frequency to run the odometry loop. If unspecified or set to 0 Hz, this is 250 Hz on CAN FD, and 100 Hz on CAN 2.0. </li> <li><code>odometryStandardDeviation</code> The standard deviation for odometry calculation in the form [x, y, theta]\u1d40, with units in meters and radians </li> <li><code>visionStandardDeviation</code> The standard deviation for vision calculation in the form [x, y, theta]\u1d40, with units in meters and radians </li> <li><code>modules</code> Constants for each specific module </li> </ul> <p>The documentation for this class was generated from the following file <code>src/main/include/generated/TunerConstants.h</code></p>"},{"location":"summer-robot-2025/namespacectre_1_1phoenix6.html","title":"Namespace ctre::phoenix6","text":"<p>Namespace List &gt; phoenix6</p> <p>The documentation for this class was generated from the following file <code>src/main/cpp/Telemetry.cpp</code></p>"},{"location":"summer-robot-2025/namespacefrc.html","title":"Namespace frc","text":"<p>Namespace List &gt; frc</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"summer-robot-2025/namespacefrc2.html","title":"Namespace frc2","text":"<p>Namespace List &gt; frc2</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"summer-robot-2025/namespacespeeds.html","title":"Namespace speeds","text":"<p>Namespace List &gt; speeds</p> <p>More...</p>"},{"location":"summer-robot-2025/namespacespeeds.html#namespaces","title":"Namespaces","text":"Type Name namespace drive"},{"location":"summer-robot-2025/namespacespeeds.html#detailed-description","title":"Detailed Description","text":"<p>The Constants header provides a convenient place for teams to hold robot-wide numerical or boolean constants. This should not be used for any other purpose.</p> <p>It is generally a good idea to place constants into subsystem- or command-specific namespaces within this header, which can then be used where they are needed. </p> <p>The documentation for this class was generated from the following file <code>src/main/include/Constants.h</code></p>"},{"location":"summer-robot-2025/namespacespeeds_1_1drive.html","title":"Namespace speeds::drive","text":"<p>Namespace List &gt; speeds &gt; drive</p>"},{"location":"summer-robot-2025/namespacespeeds_1_1drive.html#public-attributes","title":"Public Attributes","text":"Type Name constexpr double driveSpeedMultiplier   = <code>0.5</code> constexpr double turboDriveSpeedMultiplier   = <code>0.75</code> constexpr double turboTurnSpeedMultiplier   = <code>1.25</code> constexpr double turnSpeedMultiplier   = <code>1.25</code>"},{"location":"summer-robot-2025/namespacespeeds_1_1drive.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"summer-robot-2025/namespacespeeds_1_1drive.html#variable-drivespeedmultiplier","title":"variable driveSpeedMultiplier","text":"<pre><code>constexpr double speeds::drive::driveSpeedMultiplier;\n</code></pre>"},{"location":"summer-robot-2025/namespacespeeds_1_1drive.html#variable-turbodrivespeedmultiplier","title":"variable turboDriveSpeedMultiplier","text":"<pre><code>constexpr double speeds::drive::turboDriveSpeedMultiplier;\n</code></pre>"},{"location":"summer-robot-2025/namespacespeeds_1_1drive.html#variable-turboturnspeedmultiplier","title":"variable turboTurnSpeedMultiplier","text":"<pre><code>constexpr double speeds::drive::turboTurnSpeedMultiplier;\n</code></pre>"},{"location":"summer-robot-2025/namespacespeeds_1_1drive.html#variable-turnspeedmultiplier","title":"variable turnSpeedMultiplier","text":"<pre><code>constexpr double speeds::drive::turnSpeedMultiplier;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/main/include/Constants.h</code></p>"},{"location":"summer-robot-2025/namespacesubsystems.html","title":"Namespace subsystems","text":"<p>Namespace List &gt; subsystems</p>"},{"location":"summer-robot-2025/namespacesubsystems.html#classes","title":"Classes","text":"Type Name class CommandSwerveDrivetrain Class that extends the Phoenix 6 SwerveDrivetrain class and implements Subsystem so it can easily be used in command-based projects. <p>The documentation for this class was generated from the following file <code>src/main/include/generated/TunerConstants.h</code></p>"},{"location":"summer-robot-2025/classsubsystems_1_1CommandSwerveDrivetrain.html","title":"Class subsystems::CommandSwerveDrivetrain","text":"<p>ClassList &gt; subsystems &gt; CommandSwerveDrivetrain</p> <p>Class that extends the Phoenix 6 SwerveDrivetrain class and implements Subsystem so it can easily be used in command-based projects. </p> <ul> <li><code>#include &lt;CommandSwerveDrivetrain.h&gt;</code></li> </ul> <p>Inherits the following classes: frc2::SubsystemBase,  TunerSwerveDrivetrain</p>"},{"location":"summer-robot-2025/classsubsystems_1_1CommandSwerveDrivetrain.html#public-types-inherited-from-tunerswervedrivetrain","title":"Public Types inherited from TunerSwerveDrivetrain","text":"<p>See TunerSwerveDrivetrain</p> Type Name typedef swerve::SwerveModuleConstants&lt; configs::TalonFXConfiguration, configs::TalonFXConfiguration, configs::CANcoderConfiguration &gt; SwerveModuleConstants"},{"location":"summer-robot-2025/classsubsystems_1_1CommandSwerveDrivetrain.html#public-functions","title":"Public Functions","text":"Type Name void AddVisionMeasurement (frc::Pose2d visionRobotPose, units::second_t timestamp) overrideAdds a vision measurement to the Kalman Filter. This will correct the odometry pose estimate while still accounting for measurement noise. void AddVisionMeasurement (frc::Pose2d visionRobotPose, units::second_t timestamp, std::array&lt; double, 3 &gt; visionMeasurementStdDevs) overrideAdds a vision measurement to the Kalman Filter. This will correct the odometry pose estimate while still accounting for measurement noise. frc2::CommandPtr ApplyRequest (RequestSupplier request) Returns a command that applies the specified control request to this swerve drivetrain. frc2::CommandPtr ApplyRequest (RequestSupplier request) Returns a command that applies the specified control request to this swerve drivetrain. CommandSwerveDrivetrain (swerve::SwerveDrivetrainConstants const &amp; driveTrainConstants, ModuleConstants const &amp;... modules) Constructs a CTRE SwerveDrivetrain using the specified constants. CommandSwerveDrivetrain (swerve::SwerveDrivetrainConstants const &amp; driveTrainConstants, units::hertz_t odometryUpdateFrequency, ModuleConstants const &amp;... modules) Constructs a CTRE SwerveDrivetrain using the specified constants. CommandSwerveDrivetrain (swerve::SwerveDrivetrainConstants const &amp; driveTrainConstants, units::hertz_t odometryUpdateFrequency, std::array&lt; double, 3 &gt; const &amp; odometryStandardDeviation, std::array&lt; double, 3 &gt; const &amp; visionStandardDeviation, ModuleConstants const &amp;... modules) Constructs a CTRE SwerveDrivetrain using the specified constants. void Periodic () override frc2::CommandPtr SysIdDynamic (frc2::sysid::Direction direction) Runs the SysId Dynamic test in the given direction for the routine specified by m_sysIdRoutineToApply. frc2::CommandPtr SysIdQuasistatic (frc2::sysid::Direction direction) Runs the SysId Quasistatic test in the given direction for the routine specified by m_sysIdRoutineToApply."},{"location":"summer-robot-2025/classsubsystems_1_1CommandSwerveDrivetrain.html#public-functions-inherited-from-tunerswervedrivetrain","title":"Public Functions inherited from TunerSwerveDrivetrain","text":"<p>See TunerSwerveDrivetrain</p> Type Name TunerSwerveDrivetrain (swerve::SwerveDrivetrainConstants const &amp; driveTrainConstants, ModuleConstants const &amp;... modules) Constructs a CTRE SwerveDrivetrain using the specified constants. TunerSwerveDrivetrain (swerve::SwerveDrivetrainConstants const &amp; driveTrainConstants, units::hertz_t odometryUpdateFrequency, ModuleConstants const &amp;... modules) Constructs a CTRE SwerveDrivetrain using the specified constants. TunerSwerveDrivetrain (swerve::SwerveDrivetrainConstants const &amp; driveTrainConstants, units::hertz_t odometryUpdateFrequency, std::array&lt; double, 3 &gt; const &amp; odometryStandardDeviation, std::array&lt; double, 3 &gt; const &amp; visionStandardDeviation, ModuleConstants const &amp;... modules) Constructs a CTRE SwerveDrivetrain using the specified constants."},{"location":"summer-robot-2025/classsubsystems_1_1CommandSwerveDrivetrain.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"summer-robot-2025/classsubsystems_1_1CommandSwerveDrivetrain.html#function-addvisionmeasurement-12","title":"function AddVisionMeasurement [1/2]","text":"<p>Adds a vision measurement to the Kalman Filter. This will correct the odometry pose estimate while still accounting for measurement noise. <pre><code>inline void subsystems::CommandSwerveDrivetrain::AddVisionMeasurement (\n    frc::Pose2d visionRobotPose,\n    units::second_t timestamp\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>visionRobotPose</code> The pose of the robot as measured by the vision camera. </li> <li><code>timestamp</code> The timestamp of the vision measurement in seconds. </li> </ul>"},{"location":"summer-robot-2025/classsubsystems_1_1CommandSwerveDrivetrain.html#function-addvisionmeasurement-22","title":"function AddVisionMeasurement [2/2]","text":"<p>Adds a vision measurement to the Kalman Filter. This will correct the odometry pose estimate while still accounting for measurement noise. <pre><code>inline void subsystems::CommandSwerveDrivetrain::AddVisionMeasurement (\n    frc::Pose2d visionRobotPose,\n    units::second_t timestamp,\n    std::array&lt; double, 3 &gt; visionMeasurementStdDevs\n) override\n</code></pre></p> <p>Note that the vision measurement standard deviations passed into this method will continue to apply to future measurements until a subsequent call to SetVisionMeasurementStdDevs or this method.</p> <p>Parameters:</p> <ul> <li><code>visionRobotPose</code> The pose of the robot as measured by the vision camera. </li> <li><code>timestamp</code> The timestamp of the vision measurement in seconds. </li> <li><code>visionMeasurementStdDevs</code> Standard deviations of the vision pose measurement. </li> </ul>"},{"location":"summer-robot-2025/classsubsystems_1_1CommandSwerveDrivetrain.html#function-applyrequest-12","title":"function ApplyRequest [1/2]","text":"<p>Returns a command that applies the specified control request to this swerve drivetrain. <pre><code>template&lt;typename RequestSupplier&gt;\ninline frc2::CommandPtr subsystems::CommandSwerveDrivetrain::ApplyRequest (\n    RequestSupplier request\n) \n</code></pre></p> <p>This captures the returned swerve request by reference, so it must live for at least as long as the drivetrain. This can be done by storing the request as a member variable of your drivetrain subsystem or robot.</p> <p>Parameters:</p> <ul> <li><code>request</code> Function returning the request to apply </li> </ul> <p>Returns:</p> <p>Command to run </p>"},{"location":"summer-robot-2025/classsubsystems_1_1CommandSwerveDrivetrain.html#function-applyrequest-22","title":"function ApplyRequest [2/2]","text":"<p>Returns a command that applies the specified control request to this swerve drivetrain. <pre><code>template&lt;typename RequestSupplier&gt;\ninline frc2::CommandPtr subsystems::CommandSwerveDrivetrain::ApplyRequest (\n    RequestSupplier request\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>request</code> Function returning the request to apply </li> </ul> <p>Returns:</p> <p>Command to run </p>"},{"location":"summer-robot-2025/classsubsystems_1_1CommandSwerveDrivetrain.html#function-commandswervedrivetrain-13","title":"function CommandSwerveDrivetrain [1/3]","text":"<p>Constructs a CTRE SwerveDrivetrain using the specified constants. <pre><code>template&lt;std::same_as&lt; SwerveModuleConstants &gt;... ModuleConstants&gt;\ninline subsystems::CommandSwerveDrivetrain::CommandSwerveDrivetrain (\n    swerve::SwerveDrivetrainConstants const &amp; driveTrainConstants,\n    ModuleConstants const &amp;... modules\n) \n</code></pre></p> <p>This constructs the underlying hardware devices, so users should not construct the devices themselves. If they need the devices, they can access them through getters in the classes.</p> <p>Parameters:</p> <ul> <li><code>drivetrainConstants</code> Drivetrain-wide constants for the swerve drive </li> <li><code>modules</code> Constants for each specific module </li> </ul>"},{"location":"summer-robot-2025/classsubsystems_1_1CommandSwerveDrivetrain.html#function-commandswervedrivetrain-23","title":"function CommandSwerveDrivetrain [2/3]","text":"<p>Constructs a CTRE SwerveDrivetrain using the specified constants. <pre><code>template&lt;std::same_as&lt; SwerveModuleConstants &gt;... ModuleConstants&gt;\ninline subsystems::CommandSwerveDrivetrain::CommandSwerveDrivetrain (\n    swerve::SwerveDrivetrainConstants const &amp; driveTrainConstants,\n    units::hertz_t odometryUpdateFrequency,\n    ModuleConstants const &amp;... modules\n) \n</code></pre></p> <p>This constructs the underlying hardware devices, so users should not construct the devices themselves. If they need the devices, they can access them through getters in the classes.</p> <p>Parameters:</p> <ul> <li><code>driveTrainConstants</code> Drivetrain-wide constants for the swerve drive </li> <li><code>odometryUpdateFrequency</code> The frequency to run the odometry loop. If unspecified or set to 0 Hz, this is 250 Hz on CAN FD, and 100 Hz on CAN 2.0. </li> <li><code>modules</code> Constants for each specific module </li> </ul>"},{"location":"summer-robot-2025/classsubsystems_1_1CommandSwerveDrivetrain.html#function-commandswervedrivetrain-33","title":"function CommandSwerveDrivetrain [3/3]","text":"<p>Constructs a CTRE SwerveDrivetrain using the specified constants. <pre><code>template&lt;std::same_as&lt; SwerveModuleConstants &gt;... ModuleConstants&gt;\ninline subsystems::CommandSwerveDrivetrain::CommandSwerveDrivetrain (\n    swerve::SwerveDrivetrainConstants const &amp; driveTrainConstants,\n    units::hertz_t odometryUpdateFrequency,\n    std::array&lt; double, 3 &gt; const &amp; odometryStandardDeviation,\n    std::array&lt; double, 3 &gt; const &amp; visionStandardDeviation,\n    ModuleConstants const &amp;... modules\n) \n</code></pre></p> <p>This constructs the underlying hardware devices, so users should not construct the devices themselves. If they need the devices, they can access them through getters in the classes.</p> <p>Parameters:</p> <ul> <li><code>driveTrainConstants</code> Drivetrain-wide constants for the swerve drive </li> <li><code>odometryUpdateFrequency</code> The frequency to run the odometry loop. If unspecified or set to 0 Hz, this is 250 Hz on CAN FD, and 100 Hz on CAN 2.0. </li> <li><code>odometryStandardDeviation</code> The standard deviation for odometry calculation </li> <li><code>visionStandardDeviation</code> The standard deviation for vision calculation </li> <li><code>modules</code> Constants for each specific module </li> </ul>"},{"location":"summer-robot-2025/classsubsystems_1_1CommandSwerveDrivetrain.html#function-periodic","title":"function Periodic","text":"<pre><code>void subsystems::CommandSwerveDrivetrain::Periodic () override\n</code></pre>"},{"location":"summer-robot-2025/classsubsystems_1_1CommandSwerveDrivetrain.html#function-sysiddynamic","title":"function SysIdDynamic","text":"<p>Runs the SysId Dynamic test in the given direction for the routine specified by m_sysIdRoutineToApply. <pre><code>inline frc2::CommandPtr subsystems::CommandSwerveDrivetrain::SysIdDynamic (\n    frc2::sysid::Direction direction\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>direction</code> Direction of the SysId Dynamic test </li> </ul> <p>Returns:</p> <p>Command to run </p>"},{"location":"summer-robot-2025/classsubsystems_1_1CommandSwerveDrivetrain.html#function-sysidquasistatic","title":"function SysIdQuasistatic","text":"<p>Runs the SysId Quasistatic test in the given direction for the routine specified by m_sysIdRoutineToApply. <pre><code>inline frc2::CommandPtr subsystems::CommandSwerveDrivetrain::SysIdQuasistatic (\n    frc2::sysid::Direction direction\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>direction</code> Direction of the SysId Quasistatic test </li> </ul> <p>Returns:</p> <p>Command to run </p> <p>The documentation for this class was generated from the following file <code>src/main/include/subsystems/CommandSwerveDrivetrain.h</code></p>"},{"location":"summer-robot-2025/namespaceswerve.html","title":"Namespace swerve","text":"<p>Namespace List &gt; swerve</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"summer-robot-2025/dir_68267d1309a1af8e8297ef4c3efbcdba.html","title":"Dir src","text":"<p>FileList &gt; src</p>"},{"location":"summer-robot-2025/dir_68267d1309a1af8e8297ef4c3efbcdba.html#directories","title":"Directories","text":"Type Name dir main <p>The documentation for this class was generated from the following file <code>src/</code></p>"},{"location":"summer-robot-2025/dir_5eb159725f84c66aafd839904a4acdd0.html","title":"Dir src/main","text":"<p>FileList &gt; main</p>"},{"location":"summer-robot-2025/dir_5eb159725f84c66aafd839904a4acdd0.html#directories","title":"Directories","text":"Type Name dir cpp dir include <p>The documentation for this class was generated from the following file <code>src/main/</code></p>"},{"location":"summer-robot-2025/dir_fdf2b31f12d3ebb2f617242d0514024b.html","title":"Dir src/main/cpp","text":"<p>FileList &gt; cpp</p>"},{"location":"summer-robot-2025/dir_fdf2b31f12d3ebb2f617242d0514024b.html#files","title":"Files","text":"Type Name file Robot.cpp file RobotContainer.cpp file Telemetry.cpp"},{"location":"summer-robot-2025/dir_fdf2b31f12d3ebb2f617242d0514024b.html#directories","title":"Directories","text":"Type Name dir generated dir subsystems <p>The documentation for this class was generated from the following file <code>src/main/cpp/</code></p>"},{"location":"summer-robot-2025/Robot_8cpp.html","title":"File Robot.cpp","text":"<p>FileList &gt; cpp &gt; Robot.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Robot.h\"</code></li> <li><code>#include &lt;frc2/command/CommandScheduler.h&gt;</code></li> </ul>"},{"location":"summer-robot-2025/Robot_8cpp.html#public-functions","title":"Public Functions","text":"Type Name int main ()"},{"location":"summer-robot-2025/Robot_8cpp.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"summer-robot-2025/Robot_8cpp.html#function-main","title":"function main","text":"<pre><code>int main () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/main/cpp/Robot.cpp</code></p>"},{"location":"summer-robot-2025/Robot_8cpp_source.html","title":"File Robot.cpp","text":"<p>File List &gt; cpp &gt; Robot.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright (c) FIRST and other WPILib contributors.\n// Open Source Software; you can modify and/or share it under the terms of\n// the WPILib BSD license file in the root directory of this project.\n\n#include \"Robot.h\"\n\n#include &lt;frc2/command/CommandScheduler.h&gt;\n\nRobot::Robot() {}\n\nvoid Robot::RobotPeriodic() {\n  frc2::CommandScheduler::GetInstance().Run();\n}\n\nvoid Robot::DisabledInit() {}\n\nvoid Robot::DisabledPeriodic() {}\n\nvoid Robot::DisabledExit() {}\n\nvoid Robot::AutonomousInit() {\n  m_autonomousCommand = m_container.GetAutonomousCommand();\n\n  if (m_autonomousCommand) {\n    m_autonomousCommand-&gt;Schedule();\n  }\n}\n\nvoid Robot::AutonomousPeriodic() {}\n\nvoid Robot::AutonomousExit() {}\n\nvoid Robot::TeleopInit() {\n  if (m_autonomousCommand) {\n    m_autonomousCommand-&gt;Cancel();\n  }\n}\n\nvoid Robot::TeleopPeriodic() {}\n\nvoid Robot::TeleopExit() {}\n\nvoid Robot::TestInit() {\n  frc2::CommandScheduler::GetInstance().CancelAll();\n}\n\nvoid Robot::TestPeriodic() {}\n\nvoid Robot::TestExit() {}\n\n#ifndef RUNNING_FRC_TESTS\nint main() {\n  return frc::StartRobot&lt;Robot&gt;();\n}\n#endif\n</code></pre>"},{"location":"summer-robot-2025/RobotContainer_8cpp.html","title":"File RobotContainer.cpp","text":"<p>FileList &gt; cpp &gt; RobotContainer.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"RobotContainer.h\"</code></li> <li><code>#include &lt;frc2/command/Commands.h&gt;</code></li> <li><code>#include &lt;frc2/command/button/RobotModeTriggers.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/main/cpp/RobotContainer.cpp</code></p>"},{"location":"summer-robot-2025/RobotContainer_8cpp_source.html","title":"File RobotContainer.cpp","text":"<p>File List &gt; cpp &gt; RobotContainer.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright (c) FIRST and other WPILib contributors.\n// Open Source Software; you can modify and/or share it under the terms of\n// the WPILib BSD license file in the root directory of this project.\n\n#include \"RobotContainer.h\"\n\n#include &lt;frc2/command/Commands.h&gt;\n#include &lt;frc2/command/button/RobotModeTriggers.h&gt;\n\nRobotContainer::RobotContainer()\n{\n    ConfigureBindings();\n}\n\nvoid RobotContainer::ConfigureBindings()\n{\n    // Note that X is defined as forward according to WPILib convention,\n    // and Y is defined as to the left according to WPILib convention.\n    drivetrain.SetDefaultCommand(\n\n        // Drivetrain will execute this command periodically\n        drivetrain.ApplyRequest([this]() -&gt; auto&amp;&amp; {\n\n            m_driveSpeedMultiplier = speeds::drive::driveSpeedMultiplier; // Drive speed multiplier defined in constants.h\n            m_turnSpeedMultiplier = speeds::drive::turnSpeedMultiplier; // Turn speed multiplier defined in constants.h\n\n            if(joystick.RightBumper().Get()){ // Get the state of the right bumper and apply speed changes if bumper is pressed\n                m_driveSpeedMultiplier = speeds::drive::turboDriveSpeedMultiplier; // Turbo speed!!!\n                m_turnSpeedMultiplier = speeds::drive::turboTurnSpeedMultiplier; // Turbo turn rate!!!\n            }\n\n            return drive.WithVelocityX(-joystick.GetLeftY() * MaxSpeed * m_driveSpeedMultiplier) // Drive forward with negative Y (forward)\n                .WithVelocityY(-joystick.GetLeftX() * MaxSpeed * m_driveSpeedMultiplier) // Drive left with negative X (left)\n                .WithRotationalRate(-joystick.GetRightX() * MaxAngularRate * m_turnSpeedMultiplier); // Drive counterclockwise with negative X (left)\n        })\n    );\n\n    // Idle while the robot is disabled. This ensures the configured\n    // neutral mode is applied to the drive motors while disabled.\n    frc2::RobotModeTriggers::Disabled().WhileTrue(\n        drivetrain.ApplyRequest([] {\n            return swerve::requests::Idle{};\n        }).IgnoringDisable(true)\n    );\n\n    joystick.A().WhileTrue(drivetrain.ApplyRequest([this]() -&gt; auto&amp;&amp; { return brake; }));\n    joystick.B().WhileTrue(drivetrain.ApplyRequest([this]() -&gt; auto&amp;&amp; {\n        return point.WithModuleDirection(frc::Rotation2d{-joystick.GetLeftY(), -joystick.GetLeftX()});\n    }));\n\n    // Run SysId routines when holding back/start and X/Y.\n    // Note that each routine should be run exactly once in a single log.\n    (joystick.Back() &amp;&amp; joystick.Y()).WhileTrue(drivetrain.SysIdDynamic(frc2::sysid::Direction::kForward));\n    (joystick.Back() &amp;&amp; joystick.X()).WhileTrue(drivetrain.SysIdDynamic(frc2::sysid::Direction::kReverse));\n    (joystick.Start() &amp;&amp; joystick.Y()).WhileTrue(drivetrain.SysIdQuasistatic(frc2::sysid::Direction::kForward));\n    (joystick.Start() &amp;&amp; joystick.X()).WhileTrue(drivetrain.SysIdQuasistatic(frc2::sysid::Direction::kReverse));\n\n    // reset the field-centric heading on left bumper press\n    joystick.LeftBumper().OnTrue(drivetrain.RunOnce([this] { drivetrain.SeedFieldCentric(); }));\n\n\n\n    drivetrain.RegisterTelemetry([this](auto const &amp;state) { logger.Telemeterize(state); });\n}\n\nfrc2::CommandPtr RobotContainer::GetAutonomousCommand()\n{\n    return frc2::cmd::Print(\"No autonomous command configured\");\n}\n</code></pre>"},{"location":"summer-robot-2025/Telemetry_8cpp.html","title":"File Telemetry.cpp","text":"<p>FileList &gt; cpp &gt; Telemetry.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Telemetry.h\"</code></li> <li><code>#include &lt;frc/smartdashboard/SmartDashboard.h&gt;</code></li> </ul>"},{"location":"summer-robot-2025/Telemetry_8cpp.html#namespaces","title":"Namespaces","text":"Type Name namespace phoenix6 <p>The documentation for this class was generated from the following file <code>src/main/cpp/Telemetry.cpp</code></p>"},{"location":"summer-robot-2025/Telemetry_8cpp_source.html","title":"File Telemetry.cpp","text":"<p>File List &gt; cpp &gt; Telemetry.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Telemetry.h\"\n#include &lt;frc/smartdashboard/SmartDashboard.h&gt;\n\nusing namespace ctre::phoenix6;\n\nTelemetry::Telemetry(units::meters_per_second_t maxSpeed) : MaxSpeed{maxSpeed}\n{\n    SignalLogger::Start();\n\n    /* Set up the module state Mechanism2d telemetry */\n    for (size_t i = 0; i &lt; m_moduleSpeeds.size(); ++i) {\n        frc::SmartDashboard::PutData(\"Module \" + std::to_string(i), &amp;m_moduleMechanisms[i]);\n    }\n}\n\nvoid Telemetry::Telemeterize(subsystems::CommandSwerveDrivetrain::SwerveDriveState const &amp;state)\n{\n    /* Telemeterize the swerve drive state */\n    drivePose.Set(state.Pose);\n    driveSpeeds.Set(state.Speeds);\n    driveModuleStates.Set(state.ModuleStates);\n    driveModuleTargets.Set(state.ModuleTargets);\n    driveModulePositions.Set(state.ModulePositions);\n    driveTimestamp.Set(state.Timestamp.value());\n    driveOdometryFrequency.Set(1.0 / state.OdometryPeriod.value());\n\n    /* Also write to log file */\n    std::array&lt;double, 8&gt; moduleStatesArray{};\n    std::array&lt;double, 8&gt; moduleTargetsArray{};\n    for (int i = 0; i &lt; 4; ++i) {\n        moduleStatesArray[i*2 + 0] = state.ModuleStates[i].angle.Radians().value();\n        moduleStatesArray[i*2 + 1] = state.ModuleStates[i].speed.value();\n        moduleTargetsArray[i*2 + 0] = state.ModuleTargets[i].angle.Radians().value();\n        moduleTargetsArray[i*2 + 1] = state.ModuleTargets[i].speed.value();\n    }\n    SignalLogger::WriteDoubleArray(\"DriveState/Pose\", {state.Pose.X().value(), state.Pose.Y().value(), state.Pose.Rotation().Degrees().value()});\n    SignalLogger::WriteDoubleArray(\"DriveState/ModuleStates\", moduleStatesArray);\n    SignalLogger::WriteDoubleArray(\"DriveState/ModuleTargets\", moduleTargetsArray);\n    SignalLogger::WriteValue(\"DriveState/OdometryPeriod\", state.OdometryPeriod);\n\n    /* Telemeterize the pose to a Field2d */\n    fieldTypePub.Set(\"Field2d\");\n    fieldPub.Set(std::array{\n        state.Pose.X().value(),\n        state.Pose.Y().value(),\n        state.Pose.Rotation().Degrees().value()\n    });\n\n    /* Telemeterize each module state to a Mechanism2d */\n    for (size_t i = 0; i &lt; m_moduleSpeeds.size(); ++i) {\n        m_moduleDirections[i]-&gt;SetAngle(state.ModuleStates[i].angle.Degrees());\n        m_moduleSpeeds[i]-&gt;SetAngle(state.ModuleStates[i].angle.Degrees());\n        m_moduleSpeeds[i]-&gt;SetLength(state.ModuleStates[i].speed / (2 * MaxSpeed));\n    }\n}\n</code></pre>"},{"location":"summer-robot-2025/dir_548f091a957a3b24798cc181b1013b81.html","title":"Dir src/main/cpp/generated","text":"<p>FileList &gt; cpp &gt; generated</p>"},{"location":"summer-robot-2025/dir_548f091a957a3b24798cc181b1013b81.html#files","title":"Files","text":"Type Name file TunerConstants.cpp <p>The documentation for this class was generated from the following file <code>src/main/cpp/generated/</code></p>"},{"location":"summer-robot-2025/TunerConstants_8cpp.html","title":"File TunerConstants.cpp","text":"<p>FileList &gt; cpp &gt; generated &gt; TunerConstants.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"generated/TunerConstants.h\"</code></li> <li><code>#include \"subsystems/CommandSwerveDrivetrain.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/main/cpp/generated/TunerConstants.cpp</code></p>"},{"location":"summer-robot-2025/TunerConstants_8cpp_source.html","title":"File TunerConstants.cpp","text":"<p>File List &gt; cpp &gt; generated &gt; TunerConstants.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"generated/TunerConstants.h\"\n#include \"subsystems/CommandSwerveDrivetrain.h\"\n\nsubsystems::CommandSwerveDrivetrain TunerConstants::CreateDrivetrain()\n{\n    return {DrivetrainConstants, FrontLeft, FrontRight, BackLeft, BackRight};\n}\n</code></pre>"},{"location":"summer-robot-2025/dir_2a59f1b00facdb43e21fc1c516c8806d.html","title":"Dir src/main/cpp/subsystems","text":"<p>FileList &gt; cpp &gt; subsystems</p>"},{"location":"summer-robot-2025/dir_2a59f1b00facdb43e21fc1c516c8806d.html#files","title":"Files","text":"Type Name file CommandSwerveDrivetrain.cpp <p>The documentation for this class was generated from the following file <code>src/main/cpp/subsystems/</code></p>"},{"location":"summer-robot-2025/CommandSwerveDrivetrain_8cpp.html","title":"File CommandSwerveDrivetrain.cpp","text":"<p>FileList &gt; cpp &gt; subsystems &gt; CommandSwerveDrivetrain.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"subsystems/CommandSwerveDrivetrain.h\"</code></li> <li><code>#include &lt;frc/RobotController.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/main/cpp/subsystems/CommandSwerveDrivetrain.cpp</code></p>"},{"location":"summer-robot-2025/CommandSwerveDrivetrain_8cpp_source.html","title":"File CommandSwerveDrivetrain.cpp","text":"<p>File List &gt; cpp &gt; subsystems &gt; CommandSwerveDrivetrain.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"subsystems/CommandSwerveDrivetrain.h\"\n#include &lt;frc/RobotController.h&gt;\n\nusing namespace subsystems;\n\nvoid CommandSwerveDrivetrain::Periodic()\n{\n    /*\n     * Periodically try to apply the operator perspective.\n     * If we haven't applied the operator perspective before, then we should apply it regardless of DS state.\n     * This allows us to correct the perspective in case the robot code restarts mid-match.\n     * Otherwise, only check and apply the operator perspective if the DS is disabled.\n     * This ensures driving behavior doesn't change until an explicit disable event occurs during testing.\n     */\n    if (!m_hasAppliedOperatorPerspective || frc::DriverStation::IsDisabled()) {\n        auto const allianceColor = frc::DriverStation::GetAlliance();\n        if (allianceColor) {\n            SetOperatorPerspectiveForward(\n                *allianceColor == frc::DriverStation::Alliance::kRed\n                    ? kRedAlliancePerspectiveRotation\n                    : kBlueAlliancePerspectiveRotation\n            );\n            m_hasAppliedOperatorPerspective = true;\n        }\n    }\n}\n\nvoid CommandSwerveDrivetrain::StartSimThread()\n{\n    m_lastSimTime = utils::GetCurrentTime();\n    m_simNotifier = std::make_unique&lt;frc::Notifier&gt;([this] {\n        units::second_t const currentTime = utils::GetCurrentTime();\n        auto const deltaTime = currentTime - m_lastSimTime;\n        m_lastSimTime = currentTime;\n\n        /* use the measured time delta, get battery voltage from WPILib */\n        UpdateSimState(deltaTime, frc::RobotController::GetBatteryVoltage());\n    });\n    m_simNotifier-&gt;StartPeriodic(kSimLoopPeriod);\n}\n</code></pre>"},{"location":"summer-robot-2025/dir_df3bee86fdbfb464c3a94507855b0bdc.html","title":"Dir src/main/include","text":"<p>FileList &gt; include</p>"},{"location":"summer-robot-2025/dir_df3bee86fdbfb464c3a94507855b0bdc.html#files","title":"Files","text":"Type Name file Constants.h file Robot.h file RobotContainer.h file Telemetry.h"},{"location":"summer-robot-2025/dir_df3bee86fdbfb464c3a94507855b0bdc.html#directories","title":"Directories","text":"Type Name dir generated dir subsystems <p>The documentation for this class was generated from the following file <code>src/main/include/</code></p>"},{"location":"summer-robot-2025/Constants_8h.html","title":"File Constants.h","text":"<p>FileList &gt; include &gt; Constants.h</p> <p>Go to the source code of this file</p>"},{"location":"summer-robot-2025/Constants_8h.html#namespaces","title":"Namespaces","text":"Type Name namespace speeds namespace drive <p>The documentation for this class was generated from the following file <code>src/main/include/Constants.h</code></p>"},{"location":"summer-robot-2025/Constants_8h_source.html","title":"File Constants.h","text":"<p>File List &gt; include &gt; Constants.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright (c) FIRST and other WPILib contributors.\n// Open Source Software; you can modify and/or share it under the terms of\n// the WPILib BSD license file in the root directory of this project.\n\n#pragma once\n\nnamespace speeds {\n    namespace drive {\n        constexpr double driveSpeedMultiplier = 0.5;\n        constexpr double turnSpeedMultiplier = 1.25;\n        constexpr double turboDriveSpeedMultiplier = 0.75;\n        constexpr double turboTurnSpeedMultiplier = 1.25;\n    }\n}\n</code></pre>"},{"location":"summer-robot-2025/Robot_8h.html","title":"File Robot.h","text":"<p>FileList &gt; include &gt; Robot.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;frc/TimedRobot.h&gt;</code></li> <li><code>#include &lt;frc2/command/CommandPtr.h&gt;</code></li> <li><code>#include \"RobotContainer.h\"</code></li> </ul>"},{"location":"summer-robot-2025/Robot_8h.html#classes","title":"Classes","text":"Type Name class Robot <p>The documentation for this class was generated from the following file <code>src/main/include/Robot.h</code></p>"},{"location":"summer-robot-2025/Robot_8h_source.html","title":"File Robot.h","text":"<p>File List &gt; include &gt; Robot.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright (c) FIRST and other WPILib contributors.\n// Open Source Software; you can modify and/or share it under the terms of\n// the WPILib BSD license file in the root directory of this project.\n\n#pragma once\n\n#include &lt;optional&gt;\n\n#include &lt;frc/TimedRobot.h&gt;\n#include &lt;frc2/command/CommandPtr.h&gt;\n\n#include \"RobotContainer.h\"\n\nclass Robot : public frc::TimedRobot {\n public:\n  Robot();\n  void RobotPeriodic() override;\n  void DisabledInit() override;\n  void DisabledPeriodic() override;\n  void DisabledExit() override;\n  void AutonomousInit() override;\n  void AutonomousPeriodic() override;\n  void AutonomousExit() override;\n  void TeleopInit() override;\n  void TeleopPeriodic() override;\n  void TeleopExit() override;\n  void TestInit() override;\n  void TestPeriodic() override;\n  void TestExit() override;\n\n private:\n  std::optional&lt;frc2::CommandPtr&gt; m_autonomousCommand;\n\n  RobotContainer m_container;\n};\n</code></pre>"},{"location":"summer-robot-2025/RobotContainer_8h.html","title":"File RobotContainer.h","text":"<p>FileList &gt; include &gt; RobotContainer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;frc2/command/CommandPtr.h&gt;</code></li> <li><code>#include &lt;frc2/command/button/CommandXboxController.h&gt;</code></li> <li><code>#include \"subsystems/CommandSwerveDrivetrain.h\"</code></li> <li><code>#include \"Telemetry.h\"</code></li> <li><code>#include \"Constants.h\"</code></li> </ul>"},{"location":"summer-robot-2025/RobotContainer_8h.html#classes","title":"Classes","text":"Type Name class RobotContainer <p>The documentation for this class was generated from the following file <code>src/main/include/RobotContainer.h</code></p>"},{"location":"summer-robot-2025/RobotContainer_8h_source.html","title":"File RobotContainer.h","text":"<p>File List &gt; include &gt; RobotContainer.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright (c) FIRST and other WPILib contributors.\n// Open Source Software; you can modify and/or share it under the terms of\n// the WPILib BSD license file in the root directory of this project.\n\n#pragma once\n\n#include &lt;frc2/command/CommandPtr.h&gt;\n#include &lt;frc2/command/button/CommandXboxController.h&gt;\n#include \"subsystems/CommandSwerveDrivetrain.h\"\n#include \"Telemetry.h\"\n#include \"Constants.h\"\n\nclass RobotContainer {\nprivate:\n    units::meters_per_second_t MaxSpeed = TunerConstants::kSpeedAt12Volts; // kSpeedAt12Volts desired top speed\n    units::radians_per_second_t MaxAngularRate = 0.75_tps; // 3/4 of a rotation per second max angular velocity\n\n    double m_driveSpeedMultiplier = 0.0;\n    double m_turnSpeedMultiplier = 0.0;\n\n    /* Setting up bindings for necessary control of the swerve drive platform */\n    swerve::requests::FieldCentric drive = swerve::requests::FieldCentric{}\n        .WithDeadband(MaxSpeed * 0.1).WithRotationalDeadband(MaxAngularRate * 0.1) // Add a 10% deadband\n        .WithDriveRequestType(swerve::DriveRequestType::OpenLoopVoltage); // Use open-loop control for drive motors\n    swerve::requests::SwerveDriveBrake brake{};\n    swerve::requests::PointWheelsAt point{};\n\n    /* Note: This must be constructed before the drivetrain, otherwise we need to\n     *       define a destructor to un-register the telemetry from the drivetrain */\n    Telemetry logger{MaxSpeed};\n\n    frc2::CommandXboxController joystick{0};\n\npublic:\n    subsystems::CommandSwerveDrivetrain drivetrain{TunerConstants::CreateDrivetrain()};\n\n    RobotContainer();\n\n    frc2::CommandPtr GetAutonomousCommand();\n\nprivate:\n    void ConfigureBindings();\n};\n</code></pre>"},{"location":"summer-robot-2025/Telemetry_8h.html","title":"File Telemetry.h","text":"<p>FileList &gt; include &gt; Telemetry.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ctre/phoenix6/SignalLogger.hpp\"</code></li> <li><code>#include &lt;frc/smartdashboard/Mechanism2d.h&gt;</code></li> <li><code>#include &lt;frc/smartdashboard/MechanismLigament2d.h&gt;</code></li> <li><code>#include &lt;networktables/NetworkTableInstance.h&gt;</code></li> <li><code>#include &lt;networktables/DoubleArrayTopic.h&gt;</code></li> <li><code>#include &lt;networktables/DoubleTopic.h&gt;</code></li> <li><code>#include &lt;networktables/StringTopic.h&gt;</code></li> <li><code>#include &lt;networktables/StructArrayTopic.h&gt;</code></li> <li><code>#include &lt;networktables/StructTopic.h&gt;</code></li> <li><code>#include \"subsystems/CommandSwerveDrivetrain.h\"</code></li> </ul>"},{"location":"summer-robot-2025/Telemetry_8h.html#classes","title":"Classes","text":"Type Name class Telemetry <p>The documentation for this class was generated from the following file <code>src/main/include/Telemetry.h</code></p>"},{"location":"summer-robot-2025/Telemetry_8h_source.html","title":"File Telemetry.h","text":"<p>File List &gt; include &gt; Telemetry.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"ctre/phoenix6/SignalLogger.hpp\"\n#include &lt;frc/smartdashboard/Mechanism2d.h&gt;\n#include &lt;frc/smartdashboard/MechanismLigament2d.h&gt;\n#include &lt;networktables/NetworkTableInstance.h&gt;\n#include &lt;networktables/DoubleArrayTopic.h&gt;\n#include &lt;networktables/DoubleTopic.h&gt;\n#include &lt;networktables/StringTopic.h&gt;\n#include &lt;networktables/StructArrayTopic.h&gt;\n#include &lt;networktables/StructTopic.h&gt;\n\n#include \"subsystems/CommandSwerveDrivetrain.h\"\n\nclass Telemetry {\nprivate:\n    units::meters_per_second_t MaxSpeed;\n\n    /* What to publish over networktables for telemetry */\n    nt::NetworkTableInstance inst = nt::NetworkTableInstance::GetDefault();\n\n    /* Robot swerve drive state */\n    std::shared_ptr&lt;nt::NetworkTable&gt; driveStateTable = inst.GetTable(\"DriveState\");\n    nt::StructPublisher&lt;frc::Pose2d&gt; drivePose = driveStateTable-&gt;GetStructTopic&lt;frc::Pose2d&gt;(\"Pose\").Publish();\n    nt::StructPublisher&lt;frc::ChassisSpeeds&gt; driveSpeeds = driveStateTable-&gt;GetStructTopic&lt;frc::ChassisSpeeds&gt;(\"Speeds\").Publish();\n    nt::StructArrayPublisher&lt;frc::SwerveModuleState&gt; driveModuleStates = driveStateTable-&gt;GetStructArrayTopic&lt;frc::SwerveModuleState&gt;(\"ModuleStates\").Publish();\n    nt::StructArrayPublisher&lt;frc::SwerveModuleState&gt; driveModuleTargets = driveStateTable-&gt;GetStructArrayTopic&lt;frc::SwerveModuleState&gt;(\"ModuleTargets\").Publish();\n    nt::StructArrayPublisher&lt;frc::SwerveModulePosition&gt; driveModulePositions = driveStateTable-&gt;GetStructArrayTopic&lt;frc::SwerveModulePosition&gt;(\"ModulePositions\").Publish();\n    nt::DoublePublisher driveTimestamp = driveStateTable-&gt;GetDoubleTopic(\"Timestamp\").Publish();\n    nt::DoublePublisher driveOdometryFrequency = driveStateTable-&gt;GetDoubleTopic(\"OdometryFrequency\").Publish();\n\n    /* Robot pose for field positioning */\n    std::shared_ptr&lt;nt::NetworkTable&gt; table = inst.GetTable(\"Pose\");\n    nt::DoubleArrayPublisher fieldPub = table-&gt;GetDoubleArrayTopic(\"robotPose\").Publish();\n    nt::StringPublisher fieldTypePub = table-&gt;GetStringTopic(\".type\").Publish();\n\n    /* Mechanisms to represent the swerve module states */\n    std::array&lt;frc::Mechanism2d, 4&gt; m_moduleMechanisms{\n        frc::Mechanism2d{1, 1},\n        frc::Mechanism2d{1, 1},\n        frc::Mechanism2d{1, 1},\n        frc::Mechanism2d{1, 1},\n    };\n    /* A direction and length changing ligament for speed representation */\n    std::array&lt;frc::MechanismLigament2d *, 4&gt; m_moduleSpeeds{\n        m_moduleMechanisms[0].GetRoot(\"RootSpeed\", 0.5, 0.5)-&gt;Append&lt;frc::MechanismLigament2d&gt;(\"Speed\", 0.5, 0_deg),\n        m_moduleMechanisms[1].GetRoot(\"RootSpeed\", 0.5, 0.5)-&gt;Append&lt;frc::MechanismLigament2d&gt;(\"Speed\", 0.5, 0_deg),\n        m_moduleMechanisms[2].GetRoot(\"RootSpeed\", 0.5, 0.5)-&gt;Append&lt;frc::MechanismLigament2d&gt;(\"Speed\", 0.5, 0_deg),\n        m_moduleMechanisms[3].GetRoot(\"RootSpeed\", 0.5, 0.5)-&gt;Append&lt;frc::MechanismLigament2d&gt;(\"Speed\", 0.5, 0_deg),\n    };\n    /* A direction changing and length constant ligament for module direction */\n    std::array&lt;frc::MechanismLigament2d *, 4&gt; m_moduleDirections{\n        m_moduleMechanisms[0].GetRoot(\"RootDirection\", 0.5, 0.5)\n            -&gt;Append&lt;frc::MechanismLigament2d&gt;(\"Direction\", 0.1, 0_deg, 0, frc::Color8Bit{frc::Color::kWhite}),\n        m_moduleMechanisms[1].GetRoot(\"RootDirection\", 0.5, 0.5)\n            -&gt;Append&lt;frc::MechanismLigament2d&gt;(\"Direction\", 0.1, 0_deg, 0, frc::Color8Bit{frc::Color::kWhite}),\n        m_moduleMechanisms[2].GetRoot(\"RootDirection\", 0.5, 0.5)\n            -&gt;Append&lt;frc::MechanismLigament2d&gt;(\"Direction\", 0.1, 0_deg, 0, frc::Color8Bit{frc::Color::kWhite}),\n        m_moduleMechanisms[3].GetRoot(\"RootDirection\", 0.5, 0.5)\n            -&gt;Append&lt;frc::MechanismLigament2d&gt;(\"Direction\", 0.1, 0_deg, 0, frc::Color8Bit{frc::Color::kWhite}),\n    };\n\npublic:\n    Telemetry(units::meters_per_second_t maxSpeed);\n\n    void Telemeterize(subsystems::CommandSwerveDrivetrain::SwerveDriveState const &amp;state);\n};\n</code></pre>"},{"location":"summer-robot-2025/dir_0124c58e4f5bd23a187964ec70117c77.html","title":"Dir src/main/include/generated","text":"<p>FileList &gt; generated</p>"},{"location":"summer-robot-2025/dir_0124c58e4f5bd23a187964ec70117c77.html#files","title":"Files","text":"Type Name file TunerConstants.h <p>The documentation for this class was generated from the following file <code>src/main/include/generated/</code></p>"},{"location":"summer-robot-2025/TunerConstants_8h.html","title":"File TunerConstants.h","text":"<p>FileList &gt; generated &gt; TunerConstants.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ctre/phoenix6/swerve/SwerveDrivetrain.hpp\"</code></li> </ul>"},{"location":"summer-robot-2025/TunerConstants_8h.html#namespaces","title":"Namespaces","text":"Type Name namespace subsystems"},{"location":"summer-robot-2025/TunerConstants_8h.html#classes","title":"Classes","text":"Type Name class TunerConstants class TunerSwerveDrivetrain Swerve Drive class utilizing CTR Electronics' Phoenix 6 API with the selected device types. <p>The documentation for this class was generated from the following file <code>src/main/include/generated/TunerConstants.h</code></p>"},{"location":"summer-robot-2025/TunerConstants_8h_source.html","title":"File TunerConstants.h","text":"<p>File List &gt; generated &gt; TunerConstants.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"ctre/phoenix6/swerve/SwerveDrivetrain.hpp\"\n\nusing namespace ctre::phoenix6;\n\nnamespace subsystems {\n    /* Forward declaration */\n    class CommandSwerveDrivetrain;\n}\n\n// Generated by the Tuner X Swerve Project Generator\n// https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/index.html\nclass TunerConstants {\n    // Both sets of gains need to be tuned to your individual robot.\n\n    // The steer motor uses any SwerveModule.SteerRequestType control request with the\n    // output type specified by SwerveModuleConstants::SteerMotorClosedLoopOutput\n    static constexpr configs::Slot0Configs steerGains = configs::Slot0Configs{}\n        .WithKP(100).WithKI(0).WithKD(0.5)\n        .WithKS(0.1).WithKV(1.59).WithKA(0)\n        .WithStaticFeedforwardSign(signals::StaticFeedforwardSignValue::UseClosedLoopSign);\n    // When using closed-loop control, the drive motor uses the control\n    // output type specified by SwerveModuleConstants::DriveMotorClosedLoopOutput\n    static constexpr configs::Slot0Configs driveGains = configs::Slot0Configs{}\n        .WithKP(0.1).WithKI(0).WithKD(0)\n        .WithKS(0).WithKV(0.124);\n\n    // The closed-loop output type to use for the steer motors;\n    // This affects the PID/FF gains for the steer motors\n    static constexpr swerve::ClosedLoopOutputType kSteerClosedLoopOutput = swerve::ClosedLoopOutputType::Voltage;\n    // The closed-loop output type to use for the drive motors;\n    // This affects the PID/FF gains for the drive motors\n    static constexpr swerve::ClosedLoopOutputType kDriveClosedLoopOutput = swerve::ClosedLoopOutputType::Voltage;\n\n    // The type of motor used for the drive motor\n    static constexpr swerve::DriveMotorArrangement kDriveMotorType = swerve::DriveMotorArrangement::TalonFX_Integrated;\n    // The type of motor used for the drive motor\n    static constexpr swerve::SteerMotorArrangement kSteerMotorType = swerve::SteerMotorArrangement::TalonFX_Integrated;\n\n    // The remote sensor feedback type to use for the steer motors;\n    // When not Pro-licensed, Fused*/Sync* automatically fall back to Remote*\n    static constexpr swerve::SteerFeedbackType kSteerFeedbackType = swerve::SteerFeedbackType::FusedCANcoder;\n\n    // The stator current at which the wheels start to slip;\n    // This needs to be tuned to your individual robot\n    static constexpr units::ampere_t kSlipCurrent = 120_A;\n\n    // Initial configs for the drive and steer motors and the azimuth encoder; these cannot be null.\n    // Some configs will be overwritten; check the `With*InitialConfigs()` API documentation.\n    static constexpr configs::TalonFXConfiguration driveInitialConfigs{};\n    static constexpr configs::TalonFXConfiguration steerInitialConfigs = configs::TalonFXConfiguration{}\n        .WithCurrentLimits(\n            configs::CurrentLimitsConfigs{}\n                // Swerve azimuth does not require much torque output, so we can set a relatively low\n                // stator current limit to help avoid brownouts without impacting performance.\n                .WithStatorCurrentLimit(60_A)\n                .WithStatorCurrentLimitEnable(true)\n        );\n\n    static constexpr configs::CANcoderConfiguration encoderInitialConfigs{};\n    // Configs for the Pigeon 2; leave this nullopt to skip applying Pigeon 2 configs\n    static constexpr std::optional&lt;configs::Pigeon2Configuration&gt; pigeonConfigs = std::nullopt;\n\n    static constexpr std::string_view kCANBusName = \"\";\n\npublic:\n    // CAN bus that the devices are located on;\n    // All swerve devices must share the same CAN bus\n    static inline const CANBus kCANBus{kCANBusName, \"./logs/example.hoot\"};\n\n    // Theoretical free speed (m/s) at 12 V applied output;\n    // This needs to be tuned to your individual robot\n    static constexpr units::meters_per_second_t kSpeedAt12Volts = 5.21_mps;\n\nprivate:\n    // Every 1 rotation of the azimuth results in kCoupleRatio drive motor turns;\n    // This may need to be tuned to your individual robot\n    static constexpr units::scalar_t kCoupleRatio = 3.5714285714285716;\n\n    static constexpr units::scalar_t kDriveGearRatio = 6.122448979591837;\n    static constexpr units::scalar_t kSteerGearRatio = 12.8;\n    static constexpr units::inch_t kWheelRadius = 1.9_in;\n\n    static constexpr bool kInvertLeftSide = false;\n    static constexpr bool kInvertRightSide = true;\n\n    static constexpr int kPigeonId = 1;\n\n    // These are only used for simulation\n    static constexpr units::kilogram_square_meter_t kSteerInertia = 0.01_kg_sq_m;\n    static constexpr units::kilogram_square_meter_t kDriveInertia = 0.01_kg_sq_m;\n    // Simulated voltage necessary to overcome friction\n    static constexpr units::volt_t kSteerFrictionVoltage = 0.2_V;\n    static constexpr units::volt_t kDriveFrictionVoltage = 0.2_V;\n\npublic:\n    static constexpr swerve::SwerveDrivetrainConstants DrivetrainConstants = swerve::SwerveDrivetrainConstants{}\n            .WithCANBusName(kCANBusName)\n            .WithPigeon2Id(kPigeonId)\n            .WithPigeon2Configs(pigeonConfigs);\n\nprivate:\n    static constexpr swerve::SwerveModuleConstantsFactory ConstantCreator =\n        swerve::SwerveModuleConstantsFactory&lt;configs::TalonFXConfiguration, configs::TalonFXConfiguration, configs::CANcoderConfiguration&gt;{}\n            .WithDriveMotorGearRatio(kDriveGearRatio)\n            .WithSteerMotorGearRatio(kSteerGearRatio)\n            .WithCouplingGearRatio(kCoupleRatio)\n            .WithWheelRadius(kWheelRadius)\n            .WithSteerMotorGains(steerGains)\n            .WithDriveMotorGains(driveGains)\n            .WithSteerMotorClosedLoopOutput(kSteerClosedLoopOutput)\n            .WithDriveMotorClosedLoopOutput(kDriveClosedLoopOutput)\n            .WithSlipCurrent(kSlipCurrent)\n            .WithSpeedAt12Volts(kSpeedAt12Volts)\n            .WithDriveMotorType(kDriveMotorType)\n            .WithSteerMotorType(kSteerMotorType)\n            .WithFeedbackSource(kSteerFeedbackType)\n            .WithDriveMotorInitialConfigs(driveInitialConfigs)\n            .WithSteerMotorInitialConfigs(steerInitialConfigs)\n            .WithEncoderInitialConfigs(encoderInitialConfigs)\n            .WithSteerInertia(kSteerInertia)\n            .WithDriveInertia(kDriveInertia)\n            .WithSteerFrictionVoltage(kSteerFrictionVoltage)\n            .WithDriveFrictionVoltage(kDriveFrictionVoltage);\n\n\n    // Front Left\n    static constexpr int kFrontLeftDriveMotorId = 1;\n    static constexpr int kFrontLeftSteerMotorId = 2;\n    static constexpr int kFrontLeftEncoderId = 1;\n    static constexpr units::turn_t kFrontLeftEncoderOffset = 0.249267578125_tr;\n    static constexpr bool kFrontLeftSteerMotorInverted = false;\n    static constexpr bool kFrontLeftEncoderInverted = false;\n\n    static constexpr units::inch_t kFrontLeftXPos = 7_in;\n    static constexpr units::inch_t kFrontLeftYPos = 8.75_in;\n\n    // Front Right\n    static constexpr int kFrontRightDriveMotorId = 3;\n    static constexpr int kFrontRightSteerMotorId = 4;\n    static constexpr int kFrontRightEncoderId = 2;\n    static constexpr units::turn_t kFrontRightEncoderOffset = -0.1572265625_tr;\n    static constexpr bool kFrontRightSteerMotorInverted = false;\n    static constexpr bool kFrontRightEncoderInverted = false;\n\n    static constexpr units::inch_t kFrontRightXPos = 7_in;\n    static constexpr units::inch_t kFrontRightYPos = -8.75_in;\n\n    // Back Left\n    static constexpr int kBackLeftDriveMotorId = 7;\n    static constexpr int kBackLeftSteerMotorId = 8;\n    static constexpr int kBackLeftEncoderId = 4;\n    static constexpr units::turn_t kBackLeftEncoderOffset = 0.133056640625_tr;\n    static constexpr bool kBackLeftSteerMotorInverted = false;\n    static constexpr bool kBackLeftEncoderInverted = false;\n\n    static constexpr units::inch_t kBackLeftXPos = -7_in;\n    static constexpr units::inch_t kBackLeftYPos = 8.75_in;\n\n    // Back Right\n    static constexpr int kBackRightDriveMotorId = 5;\n    static constexpr int kBackRightSteerMotorId = 6;\n    static constexpr int kBackRightEncoderId = 3;\n    static constexpr units::turn_t kBackRightEncoderOffset = 0.455078125_tr;\n    static constexpr bool kBackRightSteerMotorInverted = false;\n    static constexpr bool kBackRightEncoderInverted = false;\n\n    static constexpr units::inch_t kBackRightXPos = -7_in;\n    static constexpr units::inch_t kBackRightYPos = -8.75_in;\n\n\npublic:\n    static constexpr swerve::SwerveModuleConstants FrontLeft = ConstantCreator.CreateModuleConstants(\n            kFrontLeftSteerMotorId, kFrontLeftDriveMotorId, kFrontLeftEncoderId, kFrontLeftEncoderOffset,\n            kFrontLeftXPos, kFrontLeftYPos, kInvertLeftSide, kFrontLeftSteerMotorInverted, kFrontLeftEncoderInverted);\n    static constexpr swerve::SwerveModuleConstants FrontRight = ConstantCreator.CreateModuleConstants(\n            kFrontRightSteerMotorId, kFrontRightDriveMotorId, kFrontRightEncoderId, kFrontRightEncoderOffset,\n            kFrontRightXPos, kFrontRightYPos, kInvertRightSide, kFrontRightSteerMotorInverted, kFrontRightEncoderInverted);\n    static constexpr swerve::SwerveModuleConstants BackLeft = ConstantCreator.CreateModuleConstants(\n            kBackLeftSteerMotorId, kBackLeftDriveMotorId, kBackLeftEncoderId, kBackLeftEncoderOffset,\n            kBackLeftXPos, kBackLeftYPos, kInvertLeftSide, kBackLeftSteerMotorInverted, kBackLeftEncoderInverted);\n    static constexpr swerve::SwerveModuleConstants BackRight = ConstantCreator.CreateModuleConstants(\n            kBackRightSteerMotorId, kBackRightDriveMotorId, kBackRightEncoderId, kBackRightEncoderOffset,\n            kBackRightXPos, kBackRightYPos, kInvertRightSide, kBackRightSteerMotorInverted, kBackRightEncoderInverted);\n\n    static subsystems::CommandSwerveDrivetrain CreateDrivetrain();\n};\n\n\nclass TunerSwerveDrivetrain : public swerve::SwerveDrivetrain&lt;hardware::TalonFX, hardware::TalonFX, hardware::CANcoder&gt; {\npublic:\n    using SwerveModuleConstants = swerve::SwerveModuleConstants&lt;configs::TalonFXConfiguration, configs::TalonFXConfiguration, configs::CANcoderConfiguration&gt;;\n\n    template &lt;std::same_as&lt;SwerveModuleConstants&gt;... ModuleConstants&gt;\n    TunerSwerveDrivetrain(swerve::SwerveDrivetrainConstants const &amp;driveTrainConstants, ModuleConstants const &amp;... modules) :\n        SwerveDrivetrain{driveTrainConstants, modules...}\n    {}\n\n    template &lt;std::same_as&lt;SwerveModuleConstants&gt;... ModuleConstants&gt;\n    TunerSwerveDrivetrain(\n        swerve::SwerveDrivetrainConstants const &amp;driveTrainConstants,\n        units::hertz_t odometryUpdateFrequency,\n        ModuleConstants const &amp;... modules\n    ) :\n        SwerveDrivetrain{driveTrainConstants, odometryUpdateFrequency, modules...}\n    {}\n\n    template &lt;std::same_as&lt;SwerveModuleConstants&gt;... ModuleConstants&gt;\n    TunerSwerveDrivetrain(\n        swerve::SwerveDrivetrainConstants const &amp;driveTrainConstants,\n        units::hertz_t odometryUpdateFrequency,\n        std::array&lt;double, 3&gt; const &amp;odometryStandardDeviation,\n        std::array&lt;double, 3&gt; const &amp;visionStandardDeviation,\n        ModuleConstants const &amp;... modules\n    ) :\n        SwerveDrivetrain{\n            driveTrainConstants, odometryUpdateFrequency,\n            odometryStandardDeviation, visionStandardDeviation, modules...\n        }\n    {}\n};\n</code></pre>"},{"location":"summer-robot-2025/dir_5b31952f813df36dabbaa31d5b8f92e5.html","title":"Dir src/main/include/subsystems","text":"<p>FileList &gt; include &gt; subsystems</p>"},{"location":"summer-robot-2025/dir_5b31952f813df36dabbaa31d5b8f92e5.html#files","title":"Files","text":"Type Name file CommandSwerveDrivetrain.h <p>The documentation for this class was generated from the following file <code>src/main/include/subsystems/</code></p>"},{"location":"summer-robot-2025/CommandSwerveDrivetrain_8h.html","title":"File CommandSwerveDrivetrain.h","text":"<p>FileList &gt; include &gt; subsystems &gt; CommandSwerveDrivetrain.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ctre/phoenix6/SignalLogger.hpp\"</code></li> <li><code>#include &lt;frc/DriverStation.h&gt;</code></li> <li><code>#include &lt;frc/Notifier.h&gt;</code></li> <li><code>#include &lt;frc2/command/CommandPtr.h&gt;</code></li> <li><code>#include &lt;frc2/command/SubsystemBase.h&gt;</code></li> <li><code>#include &lt;frc2/command/sysid/SysIdRoutine.h&gt;</code></li> <li><code>#include \"generated/TunerConstants.h\"</code></li> </ul>"},{"location":"summer-robot-2025/CommandSwerveDrivetrain_8h.html#namespaces","title":"Namespaces","text":"Type Name namespace subsystems"},{"location":"summer-robot-2025/CommandSwerveDrivetrain_8h.html#classes","title":"Classes","text":"Type Name class CommandSwerveDrivetrain Class that extends the Phoenix 6 SwerveDrivetrain class and implements Subsystem so it can easily be used in command-based projects. <p>The documentation for this class was generated from the following file <code>src/main/include/subsystems/CommandSwerveDrivetrain.h</code></p>"},{"location":"summer-robot-2025/CommandSwerveDrivetrain_8h_source.html","title":"File CommandSwerveDrivetrain.h","text":"<p>File List &gt; include &gt; subsystems &gt; CommandSwerveDrivetrain.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"ctre/phoenix6/SignalLogger.hpp\"\n\n#include &lt;frc/DriverStation.h&gt;\n#include &lt;frc/Notifier.h&gt;\n#include &lt;frc2/command/CommandPtr.h&gt;\n#include &lt;frc2/command/SubsystemBase.h&gt;\n#include &lt;frc2/command/sysid/SysIdRoutine.h&gt;\n\n#include \"generated/TunerConstants.h\"\n\nusing namespace ctre::phoenix6;\n\nnamespace subsystems {\n\nclass CommandSwerveDrivetrain : public frc2::SubsystemBase, public TunerSwerveDrivetrain {\n    static constexpr units::second_t kSimLoopPeriod = 5_ms;\n    std::unique_ptr&lt;frc::Notifier&gt; m_simNotifier;\n    units::second_t m_lastSimTime;\n\n    /* Blue alliance sees forward as 0 degrees (toward red alliance wall) */\n    static constexpr frc::Rotation2d kBlueAlliancePerspectiveRotation{0_deg};\n    /* Red alliance sees forward as 180 degrees (toward blue alliance wall) */\n    static constexpr frc::Rotation2d kRedAlliancePerspectiveRotation{180_deg};\n    /* Keep track if we've ever applied the operator perspective before or not */\n    bool m_hasAppliedOperatorPerspective = false;\n\n    /* Swerve requests to apply during SysId characterization */\n    swerve::requests::SysIdSwerveTranslation m_translationCharacterization;\n    swerve::requests::SysIdSwerveSteerGains m_steerCharacterization;\n    swerve::requests::SysIdSwerveRotation m_rotationCharacterization;\n\n    /* SysId routine for characterizing translation. This is used to find PID gains for the drive motors. */\n    frc2::sysid::SysIdRoutine m_sysIdRoutineTranslation{\n        frc2::sysid::Config{\n            std::nullopt, // Use default ramp rate (1 V/s)\n            4_V,          // Reduce dynamic step voltage to 4 V to prevent brownout\n            std::nullopt, // Use default timeout (10 s)\n            // Log state with SignalLogger class\n            [](frc::sysid::State state)\n            {\n                SignalLogger::WriteString(\"SysIdTranslation_State\", frc::sysid::SysIdRoutineLog::StateEnumToString(state));\n            }\n        },\n        frc2::sysid::Mechanism{\n            [this](units::volt_t output) { SetControl(m_translationCharacterization.WithVolts(output)); },\n            {},\n            this\n        }\n    };\n\n    /* SysId routine for characterizing steer. This is used to find PID gains for the steer motors. */\n    frc2::sysid::SysIdRoutine m_sysIdRoutineSteer{\n        frc2::sysid::Config{\n            std::nullopt, // Use default ramp rate (1 V/s)\n            7_V,          // Use dynamic voltage of 7 V\n            std::nullopt, // Use default timeout (10 s)\n            // Log state with SignalLogger class\n            [](frc::sysid::State state)\n            {\n                SignalLogger::WriteString(\"SysIdSteer_State\", frc::sysid::SysIdRoutineLog::StateEnumToString(state));\n            }\n        },\n        frc2::sysid::Mechanism{\n            [this](units::volt_t output) { SetControl(m_steerCharacterization.WithVolts(output)); },\n            {},\n            this\n        }\n    };\n\n    /*\n     * SysId routine for characterizing rotation.\n     * This is used to find PID gains for the FieldCentricFacingAngle HeadingController.\n     * See the documentation of swerve::requests::SysIdSwerveRotation for info on importing the log to SysId.\n     */\n    frc2::sysid::SysIdRoutine m_sysIdRoutineRotation{\n        frc2::sysid::Config{\n            /* This is in radians per second\u00b2, but SysId only supports \"volts per second\" */\n            units::constants::detail::PI_VAL / 6 * (1_V / 1_s),\n            /* This is in radians per second, but SysId only supports \"volts\" */\n            units::constants::detail::PI_VAL * 1_V,\n            std::nullopt, // Use default timeout (10 s)\n            // Log state with SignalLogger class\n            [](frc::sysid::State state)\n            {\n                SignalLogger::WriteString(\"SysIdRotation_State\", frc::sysid::SysIdRoutineLog::StateEnumToString(state));\n            }\n        },\n        frc2::sysid::Mechanism{\n            [this](units::volt_t output)\n            {\n                /* output is actually radians per second, but SysId only supports \"volts\" */\n                SetControl(m_rotationCharacterization.WithRotationalRate(output * (1_rad_per_s / 1_V)));\n                /* also log the requested output for SysId */\n                SignalLogger::WriteValue(\"Rotational_Rate\", output * (1_rad_per_s / 1_V));\n            },\n            {},\n            this\n        }\n    };\n\n    /* The SysId routine to test */\n    frc2::sysid::SysIdRoutine *m_sysIdRoutineToApply = &amp;m_sysIdRoutineTranslation;\n\npublic:\n    template &lt;std::same_as&lt;SwerveModuleConstants&gt;... ModuleConstants&gt;\n    CommandSwerveDrivetrain(swerve::SwerveDrivetrainConstants const &amp;driveTrainConstants, ModuleConstants const &amp;... modules) :\n        TunerSwerveDrivetrain{driveTrainConstants, modules...}\n    {\n        if (utils::IsSimulation()) {\n            StartSimThread();\n        }\n    }\n\n    template &lt;std::same_as&lt;SwerveModuleConstants&gt;... ModuleConstants&gt;\n    CommandSwerveDrivetrain(\n        swerve::SwerveDrivetrainConstants const &amp;driveTrainConstants,\n        units::hertz_t odometryUpdateFrequency,\n        ModuleConstants const &amp;... modules\n    ) :\n        TunerSwerveDrivetrain{driveTrainConstants, odometryUpdateFrequency, modules...}\n    {\n        if (utils::IsSimulation()) {\n            StartSimThread();\n        }\n    }\n\n    template &lt;std::same_as&lt;SwerveModuleConstants&gt;... ModuleConstants&gt;\n    CommandSwerveDrivetrain(\n        swerve::SwerveDrivetrainConstants const &amp;driveTrainConstants,\n        units::hertz_t odometryUpdateFrequency,\n        std::array&lt;double, 3&gt; const &amp;odometryStandardDeviation,\n        std::array&lt;double, 3&gt; const &amp;visionStandardDeviation,\n        ModuleConstants const &amp;... modules\n    ) :\n        TunerSwerveDrivetrain{\n            driveTrainConstants, odometryUpdateFrequency,\n            odometryStandardDeviation, visionStandardDeviation, modules...\n        }\n    {\n        if (utils::IsSimulation()) {\n            StartSimThread();\n        }\n    }\n\n    template &lt;typename RequestSupplier&gt;\n        requires std::is_lvalue_reference_v&lt;std::invoke_result_t&lt;RequestSupplier&gt;&gt; &amp;&amp;\n            requires(RequestSupplier req, TunerSwerveDrivetrain &amp;drive) { drive.SetControl(req()); }\n    frc2::CommandPtr ApplyRequest(RequestSupplier request)\n    {\n        return Run([this, request=std::move(request)] {\n            return SetControl(request());\n        });\n    }\n\n    template &lt;typename RequestSupplier&gt;\n        requires std::negation_v&lt;std::is_lvalue_reference&lt;std::invoke_result_t&lt;RequestSupplier&gt;&gt;&gt; &amp;&amp;\n            requires(RequestSupplier req, TunerSwerveDrivetrain &amp;drive) { drive.SetControl(req()); }\n    frc2::CommandPtr ApplyRequest(RequestSupplier request)\n    {\n        return Run([this, request=std::move(request)] {\n            return SetControl(request());\n        });\n    }\n\n    void Periodic() override;\n\n    frc2::CommandPtr SysIdQuasistatic(frc2::sysid::Direction direction)\n    {\n        return m_sysIdRoutineToApply-&gt;Quasistatic(direction);\n    }\n\n    frc2::CommandPtr SysIdDynamic(frc2::sysid::Direction direction)\n    {\n        return m_sysIdRoutineToApply-&gt;Dynamic(direction);\n    }\n\n    void AddVisionMeasurement(frc::Pose2d visionRobotPose, units::second_t timestamp) override\n    {\n        TunerSwerveDrivetrain::AddVisionMeasurement(std::move(visionRobotPose), utils::FPGAToCurrentTime(timestamp));\n    }\n\n    void AddVisionMeasurement(\n        frc::Pose2d visionRobotPose,\n        units::second_t timestamp,\n        std::array&lt;double, 3&gt; visionMeasurementStdDevs) override\n    {\n        TunerSwerveDrivetrain::AddVisionMeasurement(std::move(visionRobotPose), utils::FPGAToCurrentTime(timestamp), visionMeasurementStdDevs);\n    }\n\nprivate:\n    void StartSimThread();\n};\n\n}\n</code></pre>"},{"location":"summer-robot-2025/namespaces.html","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace phoenix6 </li> <li>namespace frc </li> <li>namespace frc2 </li> <li>namespace speeds <ul> <li>namespace drive </li> </ul> </li> <li>namespace subsystems </li> <li>namespace swerve </li> </ul>"},{"location":"summer-robot-2025/classes.html","title":"Class Index","text":""},{"location":"summer-robot-2025/classes.html#c","title":"c","text":"<ul> <li>CommandSwerveDrivetrain (subsystems)</li> </ul>"},{"location":"summer-robot-2025/classes.html#r","title":"r","text":"<ul> <li>Robot</li> <li>RobotContainer</li> </ul>"},{"location":"summer-robot-2025/classes.html#t","title":"t","text":"<ul> <li>Telemetry</li> <li>TunerConstants</li> <li>TunerSwerveDrivetrain</li> </ul>"},{"location":"summer-robot-2025/hierarchy.html","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class RobotContainer </li> <li>class Telemetry </li> <li>class TunerConstants </li> <li>class frc::TimedRobot <ul> <li>class Robot </li> </ul> </li> <li>class swerve::SwerveDrivetrain&lt; hardware::TalonFX, hardware::TalonFX, hardware::CANcoder &gt; <ul> <li>class TunerSwerveDrivetrain Swerve Drive class utilizing CTR Electronics' Phoenix 6 API with the selected device types. <ul> <li>class subsystems::CommandSwerveDrivetrain Class that extends the Phoenix 6 SwerveDrivetrain class and implements Subsystem so it can easily be used in command-based projects. </li> </ul> </li> <li>class TunerSwerveDrivetrain Swerve Drive class utilizing CTR Electronics' Phoenix 6 API with the selected device types. <ul> <li>class subsystems::CommandSwerveDrivetrain Class that extends the Phoenix 6 SwerveDrivetrain class and implements Subsystem so it can easily be used in command-based projects. </li> </ul> </li> </ul> </li> <li>class frc2::SubsystemBase <ul> <li>class subsystems::CommandSwerveDrivetrain Class that extends the Phoenix 6 SwerveDrivetrain class and implements Subsystem so it can easily be used in command-based projects. </li> </ul> </li> </ul>"},{"location":"summer-robot-2025/modules.html","title":"Modules","text":"<p>No modules found.</p>"},{"location":"summer-robot-2025/pages.html","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"summer-robot-2025/class_members.html","title":"Class Members","text":""},{"location":"summer-robot-2025/class_members.html#a","title":"a","text":"<ul> <li>AutonomousExit (Robot)</li> <li>AutonomousInit (Robot)</li> <li>AutonomousPeriodic (Robot)</li> <li>AddVisionMeasurement (subsystems::CommandSwerveDrivetrain)</li> <li>ApplyRequest (subsystems::CommandSwerveDrivetrain)</li> </ul>"},{"location":"summer-robot-2025/class_members.html#b","title":"b","text":"<ul> <li>brake (RobotContainer)</li> <li>BackLeft (TunerConstants)</li> <li>BackRight (TunerConstants)</li> </ul>"},{"location":"summer-robot-2025/class_members.html#c","title":"c","text":"<ul> <li>ConfigureBindings (RobotContainer)</li> <li>ConstantCreator (TunerConstants)</li> <li>CreateDrivetrain (TunerConstants)</li> <li>CommandSwerveDrivetrain (subsystems::CommandSwerveDrivetrain)</li> </ul>"},{"location":"summer-robot-2025/class_members.html#d","title":"d","text":"<ul> <li>DisabledExit (Robot)</li> <li>DisabledInit (Robot)</li> <li>DisabledPeriodic (Robot)</li> <li>drive (RobotContainer)</li> <li>drivetrain (RobotContainer)</li> <li>driveModulePositions (Telemetry)</li> <li>driveModuleStates (Telemetry)</li> <li>driveModuleTargets (Telemetry)</li> <li>driveOdometryFrequency (Telemetry)</li> <li>drivePose (Telemetry)</li> <li>driveSpeeds (Telemetry)</li> <li>driveStateTable (Telemetry)</li> <li>driveTimestamp (Telemetry)</li> <li>DrivetrainConstants (TunerConstants)</li> <li>driveGains (TunerConstants)</li> <li>driveInitialConfigs (TunerConstants)</li> </ul>"},{"location":"summer-robot-2025/class_members.html#e","title":"e","text":"<ul> <li>encoderInitialConfigs (TunerConstants)</li> </ul>"},{"location":"summer-robot-2025/class_members.html#f","title":"f","text":"<ul> <li>fieldPub (Telemetry)</li> <li>fieldTypePub (Telemetry)</li> <li>FrontLeft (TunerConstants)</li> <li>FrontRight (TunerConstants)</li> </ul>"},{"location":"summer-robot-2025/class_members.html#g","title":"g","text":"<ul> <li>GetAutonomousCommand (RobotContainer)</li> </ul>"},{"location":"summer-robot-2025/class_members.html#i","title":"i","text":"<ul> <li>inst (Telemetry)</li> </ul>"},{"location":"summer-robot-2025/class_members.html#j","title":"j","text":"<ul> <li>joystick (RobotContainer)</li> </ul>"},{"location":"summer-robot-2025/class_members.html#k","title":"k","text":"<ul> <li>kBackLeftDriveMotorId (TunerConstants)</li> <li>kBackLeftEncoderId (TunerConstants)</li> <li>kBackLeftEncoderInverted (TunerConstants)</li> <li>kBackLeftEncoderOffset (TunerConstants)</li> <li>kBackLeftSteerMotorId (TunerConstants)</li> <li>kBackLeftSteerMotorInverted (TunerConstants)</li> <li>kBackLeftXPos (TunerConstants)</li> <li>kBackLeftYPos (TunerConstants)</li> <li>kBackRightDriveMotorId (TunerConstants)</li> <li>kBackRightEncoderId (TunerConstants)</li> <li>kBackRightEncoderInverted (TunerConstants)</li> <li>kBackRightEncoderOffset (TunerConstants)</li> <li>kBackRightSteerMotorId (TunerConstants)</li> <li>kBackRightSteerMotorInverted (TunerConstants)</li> <li>kBackRightXPos (TunerConstants)</li> <li>kBackRightYPos (TunerConstants)</li> <li>kCANBus (TunerConstants)</li> <li>kCANBusName (TunerConstants)</li> <li>kCoupleRatio (TunerConstants)</li> <li>kDriveClosedLoopOutput (TunerConstants)</li> <li>kDriveFrictionVoltage (TunerConstants)</li> <li>kDriveGearRatio (TunerConstants)</li> <li>kDriveInertia (TunerConstants)</li> <li>kDriveMotorType (TunerConstants)</li> <li>kFrontLeftDriveMotorId (TunerConstants)</li> <li>kFrontLeftEncoderId (TunerConstants)</li> <li>kFrontLeftEncoderInverted (TunerConstants)</li> <li>kFrontLeftEncoderOffset (TunerConstants)</li> <li>kFrontLeftSteerMotorId (TunerConstants)</li> <li>kFrontLeftSteerMotorInverted (TunerConstants)</li> <li>kFrontLeftXPos (TunerConstants)</li> <li>kFrontLeftYPos (TunerConstants)</li> <li>kFrontRightDriveMotorId (TunerConstants)</li> <li>kFrontRightEncoderId (TunerConstants)</li> <li>kFrontRightEncoderInverted (TunerConstants)</li> <li>kFrontRightEncoderOffset (TunerConstants)</li> <li>kFrontRightSteerMotorId (TunerConstants)</li> <li>kFrontRightSteerMotorInverted (TunerConstants)</li> <li>kFrontRightXPos (TunerConstants)</li> <li>kFrontRightYPos (TunerConstants)</li> <li>kInvertLeftSide (TunerConstants)</li> <li>kInvertRightSide (TunerConstants)</li> <li>kPigeonId (TunerConstants)</li> <li>kSlipCurrent (TunerConstants)</li> <li>kSpeedAt12Volts (TunerConstants)</li> <li>kSteerClosedLoopOutput (TunerConstants)</li> <li>kSteerFeedbackType (TunerConstants)</li> <li>kSteerFrictionVoltage (TunerConstants)</li> <li>kSteerGearRatio (TunerConstants)</li> <li>kSteerInertia (TunerConstants)</li> <li>kSteerMotorType (TunerConstants)</li> <li>kWheelRadius (TunerConstants)</li> <li>kBlueAlliancePerspectiveRotation (subsystems::CommandSwerveDrivetrain)</li> <li>kRedAlliancePerspectiveRotation (subsystems::CommandSwerveDrivetrain)</li> <li>kSimLoopPeriod (subsystems::CommandSwerveDrivetrain)</li> </ul>"},{"location":"summer-robot-2025/class_members.html#l","title":"l","text":"<ul> <li>logger (RobotContainer)</li> </ul>"},{"location":"summer-robot-2025/class_members.html#m","title":"m","text":"<ul> <li>m_autonomousCommand (Robot)</li> <li>m_container (Robot)</li> <li>MaxAngularRate (RobotContainer)</li> <li>MaxSpeed (RobotContainer, Telemetry)</li> <li>m_driveSpeedMultiplier (RobotContainer)</li> <li>m_turnSpeedMultiplier (RobotContainer)</li> <li>m_moduleDirections (Telemetry)</li> <li>m_moduleMechanisms (Telemetry)</li> <li>m_moduleSpeeds (Telemetry)</li> <li>m_hasAppliedOperatorPerspective (subsystems::CommandSwerveDrivetrain)</li> <li>m_lastSimTime (subsystems::CommandSwerveDrivetrain)</li> <li>m_rotationCharacterization (subsystems::CommandSwerveDrivetrain)</li> <li>m_simNotifier (subsystems::CommandSwerveDrivetrain)</li> <li>m_steerCharacterization (subsystems::CommandSwerveDrivetrain)</li> <li>m_sysIdRoutineRotation (subsystems::CommandSwerveDrivetrain)</li> <li>m_sysIdRoutineSteer (subsystems::CommandSwerveDrivetrain)</li> <li>m_sysIdRoutineToApply (subsystems::CommandSwerveDrivetrain)</li> <li>m_sysIdRoutineTranslation (subsystems::CommandSwerveDrivetrain)</li> <li>m_translationCharacterization (subsystems::CommandSwerveDrivetrain)</li> </ul>"},{"location":"summer-robot-2025/class_members.html#p","title":"p","text":"<ul> <li>point (RobotContainer)</li> <li>pigeonConfigs (TunerConstants)</li> <li>Periodic (subsystems::CommandSwerveDrivetrain)</li> </ul>"},{"location":"summer-robot-2025/class_members.html#r","title":"r","text":"<ul> <li>Robot (Robot)</li> <li>RobotPeriodic (Robot)</li> <li>RobotContainer (RobotContainer)</li> </ul>"},{"location":"summer-robot-2025/class_members.html#s","title":"s","text":"<ul> <li>steerGains (TunerConstants)</li> <li>steerInitialConfigs (TunerConstants)</li> <li>SwerveModuleConstants (TunerSwerveDrivetrain)</li> <li>StartSimThread (subsystems::CommandSwerveDrivetrain)</li> <li>SysIdDynamic (subsystems::CommandSwerveDrivetrain)</li> <li>SysIdQuasistatic (subsystems::CommandSwerveDrivetrain)</li> </ul>"},{"location":"summer-robot-2025/class_members.html#t","title":"t","text":"<ul> <li>TeleopExit (Robot)</li> <li>TeleopInit (Robot)</li> <li>TeleopPeriodic (Robot)</li> <li>TestExit (Robot)</li> <li>TestInit (Robot)</li> <li>TestPeriodic (Robot)</li> <li>Telemeterize (Telemetry)</li> <li>Telemetry (Telemetry)</li> <li>table (Telemetry)</li> <li>TunerSwerveDrivetrain (TunerSwerveDrivetrain)</li> </ul>"},{"location":"summer-robot-2025/class_member_functions.html","title":"Class Member Functions","text":""},{"location":"summer-robot-2025/class_member_functions.html#a","title":"a","text":"<ul> <li>AutonomousExit (Robot)</li> <li>AutonomousInit (Robot)</li> <li>AutonomousPeriodic (Robot)</li> <li>AddVisionMeasurement (subsystems::CommandSwerveDrivetrain)</li> <li>ApplyRequest (subsystems::CommandSwerveDrivetrain)</li> </ul>"},{"location":"summer-robot-2025/class_member_functions.html#c","title":"c","text":"<ul> <li>ConfigureBindings (RobotContainer)</li> <li>CreateDrivetrain (TunerConstants)</li> <li>CommandSwerveDrivetrain (subsystems::CommandSwerveDrivetrain)</li> </ul>"},{"location":"summer-robot-2025/class_member_functions.html#d","title":"d","text":"<ul> <li>DisabledExit (Robot)</li> <li>DisabledInit (Robot)</li> <li>DisabledPeriodic (Robot)</li> </ul>"},{"location":"summer-robot-2025/class_member_functions.html#g","title":"g","text":"<ul> <li>GetAutonomousCommand (RobotContainer)</li> </ul>"},{"location":"summer-robot-2025/class_member_functions.html#p","title":"p","text":"<ul> <li>Periodic (subsystems::CommandSwerveDrivetrain)</li> </ul>"},{"location":"summer-robot-2025/class_member_functions.html#r","title":"r","text":"<ul> <li>Robot (Robot)</li> <li>RobotPeriodic (Robot)</li> <li>RobotContainer (RobotContainer)</li> </ul>"},{"location":"summer-robot-2025/class_member_functions.html#s","title":"s","text":"<ul> <li>StartSimThread (subsystems::CommandSwerveDrivetrain)</li> <li>SysIdDynamic (subsystems::CommandSwerveDrivetrain)</li> <li>SysIdQuasistatic (subsystems::CommandSwerveDrivetrain)</li> </ul>"},{"location":"summer-robot-2025/class_member_functions.html#t","title":"t","text":"<ul> <li>TeleopExit (Robot)</li> <li>TeleopInit (Robot)</li> <li>TeleopPeriodic (Robot)</li> <li>TestExit (Robot)</li> <li>TestInit (Robot)</li> <li>TestPeriodic (Robot)</li> <li>Telemeterize (Telemetry)</li> <li>Telemetry (Telemetry)</li> <li>TunerSwerveDrivetrain (TunerSwerveDrivetrain)</li> </ul>"},{"location":"summer-robot-2025/class_member_variables.html","title":"Class Member Variables","text":""},{"location":"summer-robot-2025/class_member_variables.html#b","title":"b","text":"<ul> <li>brake (RobotContainer)</li> <li>BackLeft (TunerConstants)</li> <li>BackRight (TunerConstants)</li> </ul>"},{"location":"summer-robot-2025/class_member_variables.html#c","title":"c","text":"<ul> <li>ConstantCreator (TunerConstants)</li> </ul>"},{"location":"summer-robot-2025/class_member_variables.html#d","title":"d","text":"<ul> <li>drive (RobotContainer)</li> <li>drivetrain (RobotContainer)</li> <li>driveModulePositions (Telemetry)</li> <li>driveModuleStates (Telemetry)</li> <li>driveModuleTargets (Telemetry)</li> <li>driveOdometryFrequency (Telemetry)</li> <li>drivePose (Telemetry)</li> <li>driveSpeeds (Telemetry)</li> <li>driveStateTable (Telemetry)</li> <li>driveTimestamp (Telemetry)</li> <li>DrivetrainConstants (TunerConstants)</li> <li>driveGains (TunerConstants)</li> <li>driveInitialConfigs (TunerConstants)</li> </ul>"},{"location":"summer-robot-2025/class_member_variables.html#e","title":"e","text":"<ul> <li>encoderInitialConfigs (TunerConstants)</li> </ul>"},{"location":"summer-robot-2025/class_member_variables.html#f","title":"f","text":"<ul> <li>fieldPub (Telemetry)</li> <li>fieldTypePub (Telemetry)</li> <li>FrontLeft (TunerConstants)</li> <li>FrontRight (TunerConstants)</li> </ul>"},{"location":"summer-robot-2025/class_member_variables.html#i","title":"i","text":"<ul> <li>inst (Telemetry)</li> </ul>"},{"location":"summer-robot-2025/class_member_variables.html#j","title":"j","text":"<ul> <li>joystick (RobotContainer)</li> </ul>"},{"location":"summer-robot-2025/class_member_variables.html#k","title":"k","text":"<ul> <li>kBackLeftDriveMotorId (TunerConstants)</li> <li>kBackLeftEncoderId (TunerConstants)</li> <li>kBackLeftEncoderInverted (TunerConstants)</li> <li>kBackLeftEncoderOffset (TunerConstants)</li> <li>kBackLeftSteerMotorId (TunerConstants)</li> <li>kBackLeftSteerMotorInverted (TunerConstants)</li> <li>kBackLeftXPos (TunerConstants)</li> <li>kBackLeftYPos (TunerConstants)</li> <li>kBackRightDriveMotorId (TunerConstants)</li> <li>kBackRightEncoderId (TunerConstants)</li> <li>kBackRightEncoderInverted (TunerConstants)</li> <li>kBackRightEncoderOffset (TunerConstants)</li> <li>kBackRightSteerMotorId (TunerConstants)</li> <li>kBackRightSteerMotorInverted (TunerConstants)</li> <li>kBackRightXPos (TunerConstants)</li> <li>kBackRightYPos (TunerConstants)</li> <li>kCANBus (TunerConstants)</li> <li>kCANBusName (TunerConstants)</li> <li>kCoupleRatio (TunerConstants)</li> <li>kDriveClosedLoopOutput (TunerConstants)</li> <li>kDriveFrictionVoltage (TunerConstants)</li> <li>kDriveGearRatio (TunerConstants)</li> <li>kDriveInertia (TunerConstants)</li> <li>kDriveMotorType (TunerConstants)</li> <li>kFrontLeftDriveMotorId (TunerConstants)</li> <li>kFrontLeftEncoderId (TunerConstants)</li> <li>kFrontLeftEncoderInverted (TunerConstants)</li> <li>kFrontLeftEncoderOffset (TunerConstants)</li> <li>kFrontLeftSteerMotorId (TunerConstants)</li> <li>kFrontLeftSteerMotorInverted (TunerConstants)</li> <li>kFrontLeftXPos (TunerConstants)</li> <li>kFrontLeftYPos (TunerConstants)</li> <li>kFrontRightDriveMotorId (TunerConstants)</li> <li>kFrontRightEncoderId (TunerConstants)</li> <li>kFrontRightEncoderInverted (TunerConstants)</li> <li>kFrontRightEncoderOffset (TunerConstants)</li> <li>kFrontRightSteerMotorId (TunerConstants)</li> <li>kFrontRightSteerMotorInverted (TunerConstants)</li> <li>kFrontRightXPos (TunerConstants)</li> <li>kFrontRightYPos (TunerConstants)</li> <li>kInvertLeftSide (TunerConstants)</li> <li>kInvertRightSide (TunerConstants)</li> <li>kPigeonId (TunerConstants)</li> <li>kSlipCurrent (TunerConstants)</li> <li>kSpeedAt12Volts (TunerConstants)</li> <li>kSteerClosedLoopOutput (TunerConstants)</li> <li>kSteerFeedbackType (TunerConstants)</li> <li>kSteerFrictionVoltage (TunerConstants)</li> <li>kSteerGearRatio (TunerConstants)</li> <li>kSteerInertia (TunerConstants)</li> <li>kSteerMotorType (TunerConstants)</li> <li>kWheelRadius (TunerConstants)</li> <li>kBlueAlliancePerspectiveRotation (subsystems::CommandSwerveDrivetrain)</li> <li>kRedAlliancePerspectiveRotation (subsystems::CommandSwerveDrivetrain)</li> <li>kSimLoopPeriod (subsystems::CommandSwerveDrivetrain)</li> </ul>"},{"location":"summer-robot-2025/class_member_variables.html#l","title":"l","text":"<ul> <li>logger (RobotContainer)</li> </ul>"},{"location":"summer-robot-2025/class_member_variables.html#m","title":"m","text":"<ul> <li>m_autonomousCommand (Robot)</li> <li>m_container (Robot)</li> <li>MaxAngularRate (RobotContainer)</li> <li>MaxSpeed (RobotContainer, Telemetry)</li> <li>m_driveSpeedMultiplier (RobotContainer)</li> <li>m_turnSpeedMultiplier (RobotContainer)</li> <li>m_moduleDirections (Telemetry)</li> <li>m_moduleMechanisms (Telemetry)</li> <li>m_moduleSpeeds (Telemetry)</li> <li>m_hasAppliedOperatorPerspective (subsystems::CommandSwerveDrivetrain)</li> <li>m_lastSimTime (subsystems::CommandSwerveDrivetrain)</li> <li>m_rotationCharacterization (subsystems::CommandSwerveDrivetrain)</li> <li>m_simNotifier (subsystems::CommandSwerveDrivetrain)</li> <li>m_steerCharacterization (subsystems::CommandSwerveDrivetrain)</li> <li>m_sysIdRoutineRotation (subsystems::CommandSwerveDrivetrain)</li> <li>m_sysIdRoutineSteer (subsystems::CommandSwerveDrivetrain)</li> <li>m_sysIdRoutineToApply (subsystems::CommandSwerveDrivetrain)</li> <li>m_sysIdRoutineTranslation (subsystems::CommandSwerveDrivetrain)</li> <li>m_translationCharacterization (subsystems::CommandSwerveDrivetrain)</li> </ul>"},{"location":"summer-robot-2025/class_member_variables.html#p","title":"p","text":"<ul> <li>point (RobotContainer)</li> <li>pigeonConfigs (TunerConstants)</li> </ul>"},{"location":"summer-robot-2025/class_member_variables.html#s","title":"s","text":"<ul> <li>steerGains (TunerConstants)</li> <li>steerInitialConfigs (TunerConstants)</li> </ul>"},{"location":"summer-robot-2025/class_member_variables.html#t","title":"t","text":"<ul> <li>table (Telemetry)</li> </ul>"},{"location":"summer-robot-2025/class_member_typedefs.html","title":"Class Member Typedefs","text":""},{"location":"summer-robot-2025/class_member_typedefs.html#s","title":"s","text":"<ul> <li>SwerveModuleConstants (TunerSwerveDrivetrain)</li> </ul>"},{"location":"summer-robot-2025/class_member_enums.html","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"summer-robot-2025/namespace_members.html","title":"Namespace Members","text":""},{"location":"summer-robot-2025/namespace_members.html#d","title":"d","text":"<ul> <li>driveSpeedMultiplier (speeds::drive)</li> </ul>"},{"location":"summer-robot-2025/namespace_members.html#t","title":"t","text":"<ul> <li>turboDriveSpeedMultiplier (speeds::drive)</li> <li>turboTurnSpeedMultiplier (speeds::drive)</li> <li>turnSpeedMultiplier (speeds::drive)</li> </ul>"},{"location":"summer-robot-2025/namespace_member_functions.html","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"summer-robot-2025/namespace_member_variables.html","title":"Namespace Member Variables","text":""},{"location":"summer-robot-2025/namespace_member_variables.html#d","title":"d","text":"<ul> <li>driveSpeedMultiplier (speeds::drive)</li> </ul>"},{"location":"summer-robot-2025/namespace_member_variables.html#t","title":"t","text":"<ul> <li>turboDriveSpeedMultiplier (speeds::drive)</li> <li>turboTurnSpeedMultiplier (speeds::drive)</li> <li>turnSpeedMultiplier (speeds::drive)</li> </ul>"},{"location":"summer-robot-2025/namespace_member_typedefs.html","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"summer-robot-2025/namespace_member_enums.html","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"summer-robot-2025/functions.html","title":"Functions","text":""},{"location":"summer-robot-2025/functions.html#m","title":"m","text":"<ul> <li>main (Robot.cpp)</li> </ul>"},{"location":"summer-robot-2025/macros.html","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"summer-robot-2025/variables.html","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"summer-robot-2025/links.html","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}